# ilike files {#ilike-files}

The ilike package uses an ilike file is used to specify the statistical model (priors and likelihoods) on which we will perform inference, along with the data and functions and parameters for the inference algorithm. This section gives a full description of how to specify this file. If the description here seems a bit intimidating, then head over to section \@ref(examples) to see some worked examples first, and come back to this section if you need clarification on anything.

An ilike file is an adapted version of a C++ source file: but don't let this put you off if you don't know C++! It is possible to write an ilike file without knowing any C++ at all. The functions in an ilike file can be specified using C++, R, python, julia. A section will be devoted to providing functions via each of these languages. Additionally, some functions in the file may be specified by using commands that are native to the ilike package, and different functions in the file may be specified using different languages. The ilike file is compiled before it is used for running inference algorithms.

This section fully describes the structure of the file (section \@ref(file-structure)), how to compile an ilike file (section \@ref(compiling)) and how to write functions in C++ (\@ref(C)), R (\@ref(R)), python (\@ref(python)), julia (\@ref(julia)). ilike native functions are described in section \@ref(ilike-functions).

## File structure {#file-structure}

The ilike file must contain all of the functions required to run the desired algorithm. In most cases the following will be required:

* A function that returns observed data. This is not required when using the algorithms for simulation from a target distribution that is not conditioned on data.
* A complete specification of a joint distribution. Usually this will consist of one or more prior distributions and one or more likelihoods^[We use the terminology "likelihood", although in practice we will usually specify a distribution for the data given parameters.]. To use a target distribution that is not conditioned on data, no likelihoods need to be specified, and the target is given solely by the "prior".
* Functions that are required to run the inference algorithm. For example, the proposal to use in a Metropolis-Hastings algorithm.

An ilike file consists of "blocks" of content, each of which specifies a component of the model (or in some cases the the inference algorithm). In an example of a simple model, the prior may be specified in one block, the likelihood in another, and the data in another. A block may consist of more than one function.

Each function in an ilike file must have a *function type* specified in a header in the line above the function. A header is enclosed in the characters `\***` at the beginning and `***\` at the end, with the function type written directly after the beginning characters `\***`. See, for example, in section \@ref(toy-example), the function that specifies how to evaluate the log of a prior density that has the header `/***evaluate_log_prior***/`, which defines the function type to be `evaluate_log_prior`.

For example, a block containing a prior may include two functions: `evaluate_log_prior` and `simulate_prior`. The functions included in a block depend on which algorithm we would like to run.

Blocks may be specified *explicitly* or determined *automatically*:

* To *explicitly* end a block, include the characters `//#` on a new line in the file after a function.
* The `compile` function will attempt to *automatically* determine the blocks that are present in a file.

Specifying blocks explicitly using `//#` has the benefit of avoiding ambiguity. If you decide to use the explicit approach, you need not read the next subsection, which explains how to write a file where the blocks are determined automatically.

Whether specified explicitly or automatically, the block type is determined by the function types in the block. For example, if a block contains  `evaluate_log_prior` and `simulate_prior` this, somewhat unsurprisingly, defines a prior. The following sections explain this in more detail.

### Specifying blocks automatically {#blocks-automatically}

All of the example files used in this documentation use the automatic approach to specifying a model. For simple models, we anticipate that the user will not need to think very much about the precise structure of the model file.

The compiler will determine the blocks in the file by looking at the function types in the file. The two principles that need to be followed are:

1. If a block contains multiple function types, these function types should be next to each other in the file. For example, when specifying a prior, the function types `simulate_prior` and `evaluate_log_prior` should be one after the other in the file.

2. If multiple blocks contain the same function types, the function types should always be provided in the same order. For example, when specifying multiple priors, the order of function types `simulate_prior` and `evaluate_log_prior` must be consistent across different blocks.

Regarding point 2, in almost all cases the order of the function types does not matter, as long as it is consistent across blocks. The only case where the order matters is when using "factor index" function types in MCMC proposals: these must be provided immediately *after* the associated proposal.

## Compiling an ilike file {#compiling}

To compile the ilike file `myfile.ilike`, we call

```{r,eval=FALSE}
library(ilike)
model = compile("myfile.ilike")
```

The resulting R object `model` is a list that contains all of the information in the ilike file. This object is used as input to the inference algorithms.

The remainder of this section (i.e. \@ref(compiler-output)) gives some information about what the compiler does. This is probably not of any great interest to most users, and can be skipped. but for those who would like to know a little more, read on.

### Compiler output {#compiler-output}

The end result of the compilation is an R list that is created from the blocks in the ilike file. The different block types in the file are stored in different sublists in the compilation output. For example, an ilike file with two factor blocks (one prior with function `evaluate_log_prior` and one likelihood with function `evaluate_log_likelihood`) will compile to an R list (let's call it `model`) with entries `model$factor[[1]]` and `model$factor[[2]]`. `model$factor[[1]]` is itself a list with, in this case, only one element `model$factor[[1]]$evaluate_log_prior`. This list would have two elements if additionally a `simulate_prior` function was specified, i.e. `model$factor[[1]]$simulate_prior` would also be found in the output. As expected, `model$factor[[2]]` is a list with one element `model$factor[[2]]evaluate_log_likelihood`. Each of these entries is a compiled C++ function, stored in an `Rcpp::XPtr` function pointer object [@eddelbuettel2011rcpp]. When performing inference this R list is passed into the ilike engine (which is written in C++), and the user-inputted functions are used in the relevant places.

To make the R list from the file, the procedure is as follows. The ilike file is processed by the ilike compiler to produce a C++ source file. This file is then compiled by Rcpp, with the resultant `Rcpp::XPtr` function pointers being stored in the R list. If you would like to view the C++ source file that is compiled by Rcpp, add an argument into the compile function:

```{r,eval=FALSE}
model = compile("myfile.ilike", keep_temporary_model_code = TRUE)
```

This file will be left in the working directory: its filename will be something like `model_for_compilation1_2655087.cpp`. The number at the end is generated at random to mitigate encountering a memory issue that leads R to crash^[Many thanks to Jouni Helske for suggesting this fix, and a shout out to his `bssm` package [@helske2021bssm] that uses a similar approach to passing C++ functions through an R interface.].

## C++ functions {#C}

ilike inference will be most computationally efficient if the functions are specified in C++ (or in the native ilike functions in section \@ref(ilike-functions)). The interface is designed with the aim that it is possible to use C++ functions for users with a range of different backgrounds: from those who know relatively little C++ (for whom R-like functions are provided to facilitate the process); to those who have an existing C++ code base that they would like to use to, for example, define a simulator-based model.

We have already seen an example of C++ functions in section \@ref(toy-example). Here is the `evaluate_log_prior` function from that example.

```{Rcpp,eval=FALSE}
/***evaluate_log_prior***/
double prior_eval(const Parameters &parameters)
{
  arma::colvec θ = parameters["θ"];
  return dnorm(θ[0],0.0,10.0) + dnorm(θ[1],0.0,10.0);
}
```

If you are not familiar with C++, I imagine the main thing that looks odd to you here is the "types", i.e. `double`, `Parameters` and `arma::colvec`. C++ is a typed language. In R we might write `x = 1` (or, preferably, `x <- 1`), and then R works out that the `1` that it will store in `x` is a numeric type. This is invisible from the user, until for example you want to use a function that needs to take, say, a data frame, and the variable is stored as a matrix (in which case as.data_frame(...) is handy). In C++, these types must be explicitly specified in the code. We would write, for example, `double x = 1.0;` to specify that `x` has the numeric type `double`. Note that C++ also requires a semi-colon at the end of each line.

There are several points that are worth highlighting about this function:

* The name of the function can be anything you like.

* It is a standard C++ function that, independently of being compiled by ilike would compile using a C++ compiler if all of the correct header files are included^[In fact this is also true for a whole ilike file. The headers that need to be included for the ilike package can be found in the package `inst/include` directory. Other headers from other R packages that ilike depends on are also required (see the `LinkingTo` section in the package `DESCRIPTION` file.].

* It has a return type (`double`) and argument(s) (`const Parameters &`)^[If you are not familiar with C++, and you are not clear about what this means, don't worry about this just yet. This documentation should tell you most of what you need to know to get started. If you want to understand more, [this tutorial](https://cplusplus.com/doc/tutorial/functions/) is a reasonable starting point.] that are pre-determined by the ilike package. The key point is that if a function under the `evaluate_log_prior` type does not have this return type and arguments (including the `const` and the `&`), you will receive an error. The return type and arguments for each function type are given in the following sections.

* The type `Parameters` is a class defined in the ilike package source. It operates in a similar way to an R list, or a python dictionary. There are more details about this in section \@ref(ilike-cpp-classes).

* arma::colvec is vector type found in the [armadillo](https://arma.sourceforge.net/docs.html) library. Any functions written to be compiled in ilike have access to this library courtesy of the R package `RcppArmadillo` [@eddelbuettel2014rcpparmadillo]. Parameter vectors are stored in the `Parameters` classes using armadillo matrices.

* The function `dnorm` is an C++ function provided in the ilike package for use in ilike files (or for anyone writing `Rcpp` code). More details about these functions can be found in section \@ref(ilike-cpp-functions).

In conclusion, to write a C++ function in an ilike file:

1. Write the header above the function.

2. Write the C++ function with the return type and arguments required for that function type, using ilike C++ functions to help you if you need.

### Including additional code

For anything beyond a simple model, writing all of the implementation of, say, a likelihood, within a single C++ function is quite constraining. Fortunately an ilike file gives you more flexibility than this. As an example, consider an altered version of the beginning of the ilike file from section \@ref(toy-example), in which we have added a `simulate_prior` function to go with the `evaluate_log_prior` function.

```{Rcpp,eval=FALSE}
/***data,y=get_data()***/
  
/***evaluate_log_prior***/
double prior_eval(const Parameters &parameters)
{
  double prior_mean = 0.0;
  double prior_sd = 10.0;
  arma::colvec θ = parameters["θ"];
  return dnorm(θ[0],prior_mean,prior_sd) + dnorm(θ[1],prior_mean,prior_sd);
}

/***simulate_prior***/
Parameters prior_sim(RandomNumberGenerator &rng)
{
  double prior_mean = 0.0;
  double prior_sd = 10.0;
  arma::colvec simulated(2);
  simulated[0] = rnorm(prior_mean,prior_sd);
  simulated[1] = rnorm(prior_mean,prior_sd);
  return Parameters("θ",simulated);
}
```

In both of the functions we have set the variables `prior_mean` and `prior_sd`. It is easy to imagine that we might want to try out different prior distributions by changing the mean and/or the standard deviation, but it is just as easy to imagine that we might forget to make the change in *both* functions. One way we could get around this would be to specify `prior_mean` and `prior_sd` to be global variables. To do this in ilike files, you simply need to write these lines of code before any ilike functions (i.e. those with the header lines) in the file. The amended code would look like this:

```{Rcpp,eval=FALSE}
double prior_mean = 0.0;
double prior_sd = 10.0;

/***data,y=get_data()***/
  
/***evaluate_log_prior***/
double prior_eval(const Parameters &parameters)
{
  arma::colvec θ = parameters["θ"];
  return dnorm(θ[0],prior_mean,prior_sd) + dnorm(θ[1],prior_mean,prior_sd);
}

/***simulate_prior***/
Parameters prior_sim(RandomNumberGenerator &rng)
{
  arma::colvec simulated(2);
  simulated[0] = rnorm(prior_mean,prior_sd);
  simulated[1] = rnorm(prior_mean,prior_sd);
  return Parameters("θ",simulated);
}
```

Further, ilike can also use variables or functions defined in a C++ header file, where it is `#include`d before the ilike functions. So the code could be changed to be:

```{Rcpp,eval=FALSE}
#include "priors.h"

/***data,y=get_data()***/
  
/***evaluate_log_prior***/
double prior_eval(const Parameters &parameters)
{
  arma::colvec θ = parameters["θ"];
  return dnorm(θ[0],prior_mean,prior_sd) + dnorm(θ[1],prior_mean,prior_sd);
}

/***simulate_prior***/
Parameters prior_sim(RandomNumberGenerator &rng)
{
  arma::colvec simulated(2);
  simulated[0] = rnorm(prior_mean,prior_sd);
  simulated[1] = rnorm(prior_mean,prior_sd);
  return Parameters("θ",simulated);
}
```

where the file `priors.h` is in the working directory and contains

```{Rcpp,eval=FALSE}
double prior_mean = 0.0;
double prior_sd = 10.0;
```

### ilike C++ classes {#ilike-cpp-classes}

The ilike package contains one class `RandomNumberGenerator` used for generating random numbers, and two classes, `Parameters` and `Data`, which are used to pass parameters and data to and from the ilike inference engine. `RandomNumberGenerator` is a random number generator found in the `dqrng` R package [@dqrng], renamed in an attempt make it look less intimidating to the casual C++ user. For the remainder of the section, we focus on describing the `Parameters` class (`Data` has the same functionality). 

The `Parameters` class can be thought of as being similar to an R list or python dictionary, where each element is indexed by a `std::string` key, and each element has the type `arma::mat` (a matrix, from the armadillo library). Full documentation for this class can be found in the [`Parameters` file](html/parameters_8h.html) in the [ilike cpp documentation](html/index.html). The file itself can be found in the package `inst/include` directory. Here we describe the most commonly used functions.

#### Constructors

```{Rcpp,eval=FALSE}
Parameters();
```

This constructs an empty Parameters object.


```{Rcpp,eval=FALSE}
Parameters(const std::string &variable_in,
           double value_in);
```

This constructs a Parameters object with the given `double` stored in a $1\times 1$ dimensional `arma::mat` matrix, indexed by the key given by the `std::string`.

```{Rcpp,eval=FALSE}
Parameters(const std::string &variable_in,
           const arma::mat &value_in);
```

This constructs a Parameters object with the given `arma::mat` stored in the Parameters object with index by the key given by the `std::string`. An `arma::colvec` can also be supplied as an argument to this function, with the armadillo library dealing with the conversion between the types.

#### Element access

```{Rcpp,eval=FALSE}
arma::mat& operator[](const std::string &variable);
arma::mat operator[](const std::string &variable) const;
```

These functions allow: (a) the assignment to an existing `Parameters` object of a new `arma::mat`, indexed by the key given by the `std::string`; and (b) accessing in a `Parameters`object the `arma::mat`, indexed by the key given by the `std::string`.

For example, to store a column vector with the key `"x"`:

```{Rcpp,eval=FALSE}
arma::colvec a_vector(2);
a_vector[0] = 1.0;
a_vector[1] = 4.0;
Parameters parameters;
parameters["x"] = a_vector;
```

Then, to subsequently access the vector in the `parameters` object:

```{Rcpp,eval=FALSE}
arma::colvec x = parameters["x"];
```

#### Copying

```{Rcpp,eval=FALSE}
Parameters(const Parameters &another);
Parameters& operator=(const Parameters &another);
```

These functions allow a parameters object to be copied, using a copy constructor and an `operator=` respectively. Examples of each follow:

```{Rcpp,eval=FALSE}
// using a copy constructor to copy the object "parameters", which was defined in the previous code chunk
Parameters copied_parameters(parameters);

// using operator= to copy "parameters"
Parameters another_copied_parameters = parameters;
```

#### Combining

```{Rcpp,eval=FALSE}
Parameters merge(const Parameters &another) const;
```

This function combines two `Parameters` objects into one. Each element in the object taken as an argument is inserted only if its key is not equivalent to the key of any other element already in the container. For example:

```{Rcpp,eval=FALSE}
// make more vectors to store in a Parameters object
arma::colvec b_vector(1);
b_vector[0] = 5.0;

arma::colvec c_vector(1);
c_vector[0] = 12.0;

// make another Parameters object that we will merge with the one we made above.
Parameters more_parameters;
more_parameters["x"] = b_vector;
more_parameters["y"] = c_vector;

// perform the merge
// both parameters and more_parameters have the key "x",
// so the "x" element from parameters,
// and the "y" element from more_parameters are found in the result
Parameters yet_more_parameters = parameters.merge(more_parameters);
```

#### Printing

```{Rcpp,eval=FALSE}
std::ostream& operator<<(std::ostream& os, const Parameters &p);
```

This function prints a `Parameters` object to an output stream. For example, to print to console:

```{Rcpp,eval=FALSE}
std::cout << parameters;
```

### ilike C++ functions {#ilike-cpp-functions}

Functions from any C++ library may be used to simplify the writing of an ilike file, provided the functions being used are found in header files only. The `boost` library is particularly easy to use in this setting, since most of the `boost` header files are available directly through ilike's depdendece on the `BH` R package [@BH].

ilike itself contains a number of C++ functions that might be useful. Most of these provide methods for simulating points from, or evaluating the density of. various commonly used distributions. The arguments taken bv these functions are chosen to be, where possible, roughly consistent with the corresponding functions in R. All functions involving the simulation of random points require a `RandomNumberGenerator` as their first argument (most provide an interface to the corresponding functions in `boost`). The use of a `RandomNumberGenerator` distinguishes these functions from [those found in Rcpp](https://teuder.github.io/rcpp4everyone_en/220_dpqr_functions.html). Use of the ilike functions is recommended in ilike files, to ensure correct handling of the random number streams in the ilike inference engine.

Casual C++ users may not be familiar with the type `size_t`: this can be thought of as a non-negative integer.

#### hz test

---

```{Rcpp,eval=FALSE}
double hz(const arma::mat &data_in)
```

Implements Henze-Zirkler’s test for multivariate linearity: a translation into C++ of the code found in the [MVN R package](https://CRAN.R-project.org/package=MVN) [@MVN].

#### log-sum-exp

---

```{Rcpp,eval=FALSE}
double log_sum_exp(const arma::colvec &log_weights)
```

This function implements the [LogSumExp trick](https://en.wikipedia.org/wiki/LogSumExp) on the inputted vector.

#### Weighted mean and covariance

---

```{Rcpp,eval=FALSE}
arma::rowvec mean_wt(const arma::mat &x,
                     const arma::colvec &wt);
arma::mat cov_wt(const arma::mat &x,
                 const arma::colvec &wt);
```

The functions compute the weighted (using weight `wt`) mean and covariance of the data found in the rows of `x`. The vector `wt` needs to be normalised.

#### Discrete distribution

---

```{Rcpp,eval=FALSE}
size_t rdis(RandomNumberGenerator &rng,
            const arma::colvec &probabilities);
```

Generates a random number from the discrete distribution taking values $[0,n)$, with probabilities given by the vector `probabilities`, and `n` being taken to be the length of this vector. The vector `probabilities` need not be normalised.

---

```{Rcpp,eval=FALSE}
arma::uvec multiple_rdis(RandomNumberGenerator &rng,
                         size_t n,
                         const arma::colvec &probabilities);
```

Generates `n` random numbers from the discrete distribution taking values $[0,n)$, with probabilities given by the vector `probabilities`, and `n` being taken to be the length of this vector. The vector `probabilities` need not be normalised.

#### Exponential distribution

---

```{Rcpp,eval=FALSE}
double rexp(RandomNumberGenerator &rng,
            double rate);
```

Generates a random number from the exponential distribution with rate `rate`.

---

```{Rcpp,eval=FALSE}
arma::colvec rexp(RandomNumberGenerator &rng,
                  size_t n,
                  double rate);
```

Generates `n` random numbers from the exponential distribution with rate `rate`.

---

```{Rcpp,eval=FALSE}
double dexp(double x,
            double rate);
```

Evaluates the log of the exponential density with rate `rate` at the point `x`.

---

```{Rcpp,eval=FALSE}
double rtranslatedexp(RandomNumberGenerator &rng,
                      double rate,
                      double min);
```

Generates a random number from the translated (by `min`) exponential distribution with rate `rate`.

---

```{Rcpp,eval=FALSE}
arma::colvec rtranslatedexp(RandomNumberGenerator &rng,
                            size_t n,
                            double rate,
                            double min);
```

Generates `n` random numbers from the translated (by `min`) exponential distribution with rate `rate`.

---

```{Rcpp,eval=FALSE}
double dtranslatedexp(double x,
                      double rate,
                      double min);
```

Evaluates the log of the translated exponential (by `min`) density with rate `rate` at the point `x`.

#### Gamma distribution

---

```{Rcpp,eval=FALSE}
double rgamma(RandomNumberGenerator &rng,
              double shape,
              double rate);
```

Generates a random number from the gamma distribution with shape `shape` and rate `rate`.

---

```{Rcpp,eval=FALSE}
arma::colvec rgamma(RandomNumberGenerator &rng,
                    size_t n,
                    double shape,
                    double rate);
---
```  

Generates `n` random numbers from the gamma distribution with shape `shape` and rate `rate`.

```{Rcpp,eval=FALSE}
double dgamma(double x,
              double shape,
              double rate);
```

Evaluates the log of the gamma density with shape `shape` and rate `rate` at the point `x`.

#### Log-normal and multivariate log-normal distribution

---

```{Rcpp,eval=FALSE}
double rlnorm(RandomNumberGenerator &rng,
              double meanlog,
              double sdlog)
{
  boost::random::lognormal_distribution<double> my_gamma(meanlog, sdlog);
  return my_gamma(rng);
}
```

Generates a random number from the log-normal distribution with mean of the log of the variable `meanlog` and standard deviation of the log of the variable `sdlog`.

---

```{Rcpp,eval=FALSE}
arma::colvec rlnorm(RandomNumberGenerator &rng,
                    size_t n,
                    double meanlog,
                    double sdlog);
```

Generates `n` random numbers from the log-normal distribution with mean of the log of the variable `meanlog` and standard deviation of the log of the variable `sdlog`.

---

```{Rcpp,eval=FALSE}
double dlnorm(double x,
              double meanlog,
              double sdlog)
{
  if (sdlog<0)
  {
    return NAN;
  }
  if (sdlog==0)
  {
    if (x==meanlog)
      return arma::datum::inf;
    else
      return -arma::datum::inf;
  }
  return - log(x) - log(sdlog) - 0.5*log(2.0*M_PI) - 0.5*pow((log(x)-meanlog)/sdlog,2.0);
}
```

Evaluates the log of the log-normal density with mean of the log of the variable `meanlog` and standard deviation of the log of the variable `sdlog` at the point `x`.

---

```{Rcpp,eval=FALSE}
arma::colvec rmvlnorm(RandomNumberGenerator &rng,
                             const arma::colvec &mulog,
                             const arma::mat &Sigmalog);
```

Generates a random number from the multivariate log-normal distribution with mean of the log of the variable `meanlog` and covariance of the log of the variable `Sigmalog`.

---

```{Rcpp,eval=FALSE}
double dmvlnorm(const arma::colvec &x,
                       const arma::colvec &mulog,
                       const arma::mat &Sigmalog)
double dmvlnorm_using_precomp(const arma::colvec &x,
                                     const arma::colvec &mulog,
                                     const arma::mat &inv_Sigmalog,
                                     double log_det)
```

Evaluates the log of the multivariate log-normal density with mean of the log of the variable `meanlog` and covariance of the log of the variable `Sigmalog` at the point `x`. The latter function does not require the covariance as an argument: instead it takes the inverse of the covariance `inv_Sigma` and the log of the determinant of the covariance (`log_det`). This is designed for cases where the density needs to be evaluated at a number of points using the same covariance; using this function avoids performing the most expensive parts of the computation more than once.

#### Normal/Gaussian and multivariate normal/Gaussian distribution

---

```{Rcpp,eval=FALSE}
double rnorm(RandomNumberGenerator &rng);
```

Generates a random number from the standard normal distribution.

---

```{Rcpp,eval=FALSE}
arma::mat rnorm(RandomNumberGenerator &rng,
                size_t n);
```

Generates `n` random numbers from the standard normal distribution.

---

```{Rcpp,eval=FALSE}
arma::mat rnorm(RandomNumberGenerator &rng,
                std::pair<size_t,size_t> dimensions);
```

Generates a matrix (of dimension given by `dimensions`) of random numbers from the standard normal distribution.

---

```{Rcpp,eval=FALSE}
double dnorm(double x);
```

Evaluates the log of the standard normal density at the point `x`.

---

```{Rcpp,eval=FALSE}
double rnorm(RandomNumberGenerator &rng,
             double mean,
             double sd);
```

Generates a random number from the normal distribution with mean `mean` and standard deviation `sd`.

---

```{Rcpp,eval=FALSE}
arma::mat rnorm(RandomNumberGenerator &rng,
                size_t n,
                double mean,
                double sd);
```

Generates `n` random numbers from the normal distribution with mean `mean` and standard deviation `sd`.

---

```{Rcpp,eval=FALSE}
arma::mat rnorm(RandomNumberGenerator &rng,
                       std::pair<size_t,size_t> dimensions,
                       double mean,
                       double sd);
```

Generates a matrix (of dimension given by `dimensions`) of random numbers from the normal distribution with mean `mean` and standard deviation `sd`.

---

```{Rcpp,eval=FALSE}
double dnorm(double x,
             double mean,
             double sd);
```

Evaluates the log of the normal density with mean `mean` and standard deviation `sd` at the point `x`.

---

```{Rcpp,eval=FALSE}
arma::colvec dnorm(const arma::colvec &x,
                   double mean,
                   double sd);
arma::colvec dnorm(const arma::colvec &x,
                   const arma::colvec &mean,
                   double sd);
arma::colvec dnorm(const arma::colvec &x,
                   double mean,
                   const arma::colvec &sd);
arma::colvec dnorm(const arma::colvec &x,
                   const arma::colvec &mean,
                   const arma::colvec &sd);
```

Evaluates the log of the normal density with mean `mean` and standard deviation `sd` at the vector of points `x`, returning a vector. If `mean` and/or `sd` are a `double`, the same mean/sd is used for all dimensions; if a vector the corresponding entry in that vector is used for each dimension.

---

```{Rcpp,eval=FALSE}
arma::colvec rmvnorm(RandomNumberGenerator &rng,
                     const arma::colvec &mu,
                     const arma::mat &Sigma);
```

Generates a random vector from the multivariate normal distribution with mean `mu` and covariance `Sigma`.

---

```{Rcpp,eval=FALSE}
arma::mat rmvnorm(RandomNumberGenerator &rng,
                  size_t n,
                  const arma::colvec &mu,
                  const arma::mat &Sigma);
```

Generates `n` random vectors from the multivariate normal distribution with mean `mu` and covariance `Sigma`, stored in a $d\times n$ matrix, where $d$ is the dimension of the multivariate Gaussian (determined by the size of the inputted mean and covariance).

---

```{Rcpp,eval=FALSE}
double dmvnorm(const arma::colvec &x,
               const arma::colvec &mu,
               const arma::mat &Sigma);
double dmvnorm_using_precomp(const arma::colvec &x,
                             const arma::colvec &mu,
                             const arma::mat &inv_Sigma,
                             double log_det);
```

Evaluates the log of the multivariate normal density with mean `mu` and covariance `Sigma` at the vector `x`. The latter function does not require the covariance as an argument: instead it takes the inverse of the covariance `inv_Sigma` and the log of the determinant of the covariance (`log_det`). This is designed for cases where the density needs to be evaluated at a number of points using the same covariance; using this function avoids performing the most expensive parts of the computation more than once.

#### Truncated normal/Gaussian and trucated multivariate normal/Gaussian distributions

---

```{Rcpp,eval=FALSE}
double rtnorm(RandomNumberGenerator &rng,
              double min,
              double max);
```

Generates a random number from the standard truncated normal distribution, with bounds given by `min` and `max` (using the technique from @robert1995simulation).

---

```{Rcpp,eval=FALSE}
arma::mat rtnorm(RandomNumberGenerator &rng,
                 size_t n,
                 double min,
                 double max);
```

Generates `n` random numbers from the standard truncated normal distribution, with bounds given by `min` and `max` (using the technique from @robert1995simulation).

---

```{Rcpp,eval=FALSE}
arma::mat rtnorm(RandomNumberGenerator &rng,
                 std::pair<size_t,size_t> dimensions,
                 double min,
                 double max);
```

Generates a matrix (of dimension given by `dimensions`) of random numbers from the standard truncated normal distribution, with bounds given by `min` and `max` (using the technique from @robert1995simulation).

---

```{Rcpp,eval=FALSE}
double dtnorm(double x,
              double min,
              double max);
```

Evaluates the log of the standard truncated normal density, with bounds given by `min` and `max`, at the point `x`.

---

```{Rcpp,eval=FALSE}
double rtnorm(RandomNumberGenerator &rng,
              double mean,
              double sd,
              double min,
              double max);
```

Generates a random number from the truncated normal distribution with mean `mean` and standard deviation `sd`, with bounds given by `min` and `max`.

---

```{Rcpp,eval=FALSE}
arma::mat rtnorm(RandomNumberGenerator &rng,
                 size_t n,
                 double mean,
                 double sd,
                 double min,
                 double max);
```

Generates `n` random numbers from the truncated normal distribution with mean `mean` and standard deviation `sd`, with bounds given by `min` and `max`.

---

```{Rcpp,eval=FALSE}
arma::mat rtnorm(RandomNumberGenerator &rng,
                 std::pair<size_t,size_t> dimensions,
                 double mean,
                 double sd,
                 double min,
                 double max);
```

Generates a matrix (of dimension given by `dimensions`) of random numbers from the truncated normal distribution with mean `mean` and standard deviation `sd`, with bounds given by `min` and `max`.

---

```{Rcpp,eval=FALSE}
double dtnorm(double x,
              double mean,
              double sd,
              double min,
              double max);
```

Evaluates the log of the truncated normal density with mean `mean` and standard deviation `sd`, with bounds given by `min` and `max`, at the point `x`.

---

```{Rcpp,eval=FALSE}
arma::colvec dtnorm(const arma::colvec &x,
                    double mean,
                    double sd,
                    double min,
                    double max);
```

Evaluates the log of the truncated normal density with mean `mean` and standard deviation `sd`, with bounds given by `min` and `max`, at the vector of points `x`, returning a vector.

---

```{Rcpp,eval=FALSE}
arma::colvec rtmvnorm(RandomNumberGenerator &rng,
                      const arma::colvec &mu,
                      const arma::mat &Sigma,
                      const arma::colvec &min,
                      const arma::colvec &max);
```

Generates a random vector from the truncated multivariate normal distribution with mean `mu` and covariance `Sigma`, with bounds given by `min` and `max`. A simple rejection sampler is used for the implementation.

---

```{Rcpp,eval=FALSE}
arma::mat rtmvnorm(RandomNumberGenerator &rng,
                   size_t n,
                   const arma::colvec &mu,
                   const arma::mat &Sigma,
                   const arma::colvec &min,
                   const arma::colvec &max);
```

Generates `n` random vectors from the truncated multivariate normal distribution with mean `mu` and covariance `Sigma`, with bounds given by `min` and `max`, stored in a $d\times n$ matrix, where $d$ is the dimension of the multivariate Gaussian (determined by the size of the inputted mean and covariance).

#### Poisson distribution

---

```{Rcpp,eval=FALSE}
int rpois(RandomNumberGenerator &rng,
          double rate);
```

Generates a random number from the Poisson distribution with rate `rate`.

---

```{Rcpp,eval=FALSE}
arma::colvec rpois(RandomNumberGenerator &rng,
                   size_t n,
                   double rate);
```

Generates `n` random numbers from the Poisson distribution with rate `rate`.

---

```{Rcpp,eval=FALSE}
double dpois(double x,
             double rate);
```

Evaluates the log of the Poisson mass function with rate `rate` at the point `x`.

#### Uniform distribution (continuous)

---

```{Rcpp,eval=FALSE}
double runif(RandomNumberGenerator &rng);
```

Generates a random number from the uniform distribution between 0 and 1.

---

```{Rcpp,eval=FALSE}
double runif(RandomNumberGenerator &rng,
             double lower,
             double upper);
```

Generates a random number from the uniform distribution between `lower` and `upper`.

---

```{Rcpp,eval=FALSE}
arma::mat runif(RandomNumberGenerator &rng,
                const arma::mat &lower,
                const arma::mat &upper);
```

Generates a matrix of random numbers, where the $(i,j)$th element is drawn from the uniform distribution between the $(i,j)$th element of `lower` and the $(i,j)$th element of `upper`.

---

```{Rcpp,eval=FALSE}
arma::rowvec multiple_runif(RandomNumberGenerator &rng,
                            size_t n);
```

Generates `n` random numbers from the uniform distribution between 0 and 1, and stores them in a row vector.

---

```{Rcpp,eval=FALSE}
arma::rowvec multiple_runif(RandomNumberGenerator &rng,
                            size_t n,
                            double lower,
                            double upper);
```

Generates `n` random numbers from the uniform distribution between `lower` and `upper`, and stores them in a row vector.

---

```{Rcpp,eval=FALSE}
double dunif(double x);
```

Evaluates the log of the uniform density between 0 and 1 at `x`.

---

```{Rcpp,eval=FALSE}
double dunif(double x,
             double lower,
             double upper);
```

Evaluates the log of the uniform density between `lower` and `upper` at `x`.

---

```{Rcpp,eval=FALSE}
double dunif(const arma::mat &x,
             const arma::mat &lower,
             const arma::mat &upper);
```

For the $(i,j)$th element of `x`, evaluate the log of the uniform density between the $(i,j)$th element of `lower` and the $(i,j)$th element of `upper`, then take the sum of the result (i.e. the product of independent uniform densities).

## R functions {#R}

Whilst C++ functions are the most computationally efficient when used in ilike inference algorithms, using an R function may be simpler and offer close to the same performance. To use an R function in ilike, the following must be specified:

1. Details in a function header, of how the R function interfaces to ilike.

2. The R function itself, specified in a file with the same name as the ilike file, but with the `.R` extension.

This section discusses arguments in R functions, and details how to specify both the header, and the R function. Note that R functions cannot be used when parallel versions of the inference algorithms are used.

### Function arguments for R functions

When using C++ functions, each function type has predefined arguments. For example, the `evaluate_log_prior` function type has a `Parameters` object as its argument. An R function of the same type need not have these arguments, but it does have access to all of the same arguments used in the corresponding C++ function. For example an `evaluate_log_prior` function has access to an object called `parameters` that has the same content as the corresponding argument in the C++ code has.

When using the arguments in R functions, users should also be aware of the following:

- When used in an R function, a `Parameters` object is an R list, whose elements can be accessed using the R syntax `parameters$variable`.

- A `Data` object is used in the same ways as a `Parameters` object - it is an R list, and elements may be accessed using `data$variable`.

- The names of the objects that may be used is pre-specified (defined in later sections). For example, the objects available in the `evaluate_log_likelihood` function type are named `parameters` and `data`.

- In case you read the section on C++ functions and were wondering, random number streams do not need to be used in R functions.

### Function headers for R functions

For C++ functions, a function header takes the form of, for example, `/***evaluate_log_prior***/`, with the associated function following on the subsequent line. For R functions, the function type must be followed (after a comma `,`)  by the a call to the R function. For example, suppose the prior is given by a standard normal distribution, then the header would be

```{Rcpp,eval=FALSE}
/***evaluate_log_prior, dnorm(parameters$x,log=TRUE)***/
```

where `parameters$x` is the value at which the prior is to be evaluated. Here the use of `parameters$x` will be interpreted as taking the parameter `x` from the `parameters` object.

Just as when using C++ functions, each function type has a set of arguments it may use (in this case, `parameters`): these are detailed in later sections. There is some flexibility in how to use these arguments. For example, the `parameters` object may be used as a whole, or individual elements may be extracted from it. The example

```{Rcpp,eval=FALSE}
/***evaluate_log_prior, dnorm(parameters$x,log=TRUE)***/
```

takes the approach of extracting the `x` element from the `parameters` object. In the following example, the `parameters` object is used as a whole:

```{Rcpp,eval=FALSE}
/***evaluate_log_prior, my_density_log_evaluate(parameters)***/
```

Here `my_density_log_evaluate` is a function in the accompanying R file that takes the `parameters` object as an argument, for example

```{R,eval=FALSE}
my_density_log_evaluate <- function(parameters) {
  return(dnorm(parameters$x,log=TRUE))
}
```

Here `parameters` is an R list: the R analogue of the C++ class `Parameters` as was used in the C++ code.

For some function types, the output needs to be stored in an object. For example, recall the function that loads the data in the example in \@ref(toy-example):

```{Rcpp,eval=FALSE}
/***data,y=get_data()***/
```

Here, as above, the function `get_data` is defined in the accompanying R file. The use of the `=` sign will result in the output of the function being stored in a `Data` object (the output type of the `data` function type) under the variable name `y`. This data can then be accessed in, say, the `evaluate_log_likelihood` function type using `data["y"]` in a C++ function, or `data$y` in an R function. Recall the likelihood from the example in section \@ref(toy-example):

```{Rcpp,eval=FALSE}
/***evaluate_log_likelihood***/
double llhd(const Parameters &parameters,
            const Data &data)
{
  arma::colvec θ = parameters["θ"];
  double y = data["y"];
  return sum(dnorm(y,θ[0]+θ[1],1.0));
}
```

In some cases the R functions might rely on external packages. In this case, the R function should load the package at the beginning of the .R file (e.g. `library(mvtnorm)`), and the package should also be listed in the `external_packages` argument when calling the `compile` function. For example:

```{r,eval=FALSE}
model = compile("myfile.ilike", external_packages = c("mvtnorm","gk"))
```

## Python functions {#python}

In this section, we will detail how to use Python functions in ilike. The process is similar to that of using R functions. The function header must be specified in the same way as for R functions, with the function type followed by a call to the Python function. The Python function itself is specified in a file with the same name as the ilike file, but with the `.py` extension. Behind the scenes, the `reticulate` R package is used to make the python function callable from R, and hence from ilike.

The use of R as an intermediary between the Python code and the ilike inference engine results in an overhead in using Python functions, since each time a Python function is called the Python data structures must be converted to Rcpp data structures (and/or vice versa, depending on the function type). Depending on the algorithm/model combination you are using, this overhead may be significant. For example, an MCMC that uses an exact likelihood may be significantly slower when using a Python function, since the conversion overhead may be significant when compared to the cost of the likelihood evaluation. However, an ABC-MCMC algorithm that involves a costly simulation step may not be significantly affected by the overhead of using a Python function.

Python functions may be called directly from the function header just as R functions are. The code in the function header should be treated as R code, even if the function being called is a Python function - so R syntax should be used when accessing arguments in the header line (e.g. use `parameters$x` in this line to access variable `x` in the `parameters` object). In the Python function itself, `Parameters` and `Data` objects will take the form of a Python dictionary (so `parameters["x"]` would be used to access variable `x`). Python functions cannot be used with parallel inference algorithms.

The following example demonstrates how to use a Python function in ilike, in this case an additive Gaussian noise model, specified with the function type `evaluate_log_likelihood`:

```{Rcpp,eval=FALSE}
/***evaluate_log_likelihood,my_log_llhd(parameters,data)***/
```

`my_log_llhd` is specified in a file with the same name as the ilike file, but with the `.py` extension. The function `my_log_llhd` is defined as follows:

```{python,eval=FALSE}
import numpy as np
from scipy.stats import norm

def my_log_llhd(parameters,data):
  Sigma = 1.0
  return sum(norm.logpdf(data["y"],parameters["mu"],Sigma))
```

There is one part of the specification in the function header that might need to differ compared to when using an R function. When passing an integer argument to a Python function, the argument must be cast to an integer in the function header. For example, suppose the Python function `my_rnorm` (used in the data function in this case) takes an integer argument `n`, then the function header would be:

```{Rcpp,eval=FALSE}
/***data,y=my_rnorm(100L,0,1)***/
```

(note the key point: using `100L` instead of `100`) with the Python file containing:

```{python,eval=FALSE}
import numpy as np
from scipy.stats import norm

def my_rnorm(n):
  return norm.rvs(size=n)
```

### Using jax to calculate gradients

The `jax` library can be used to calculate gradients of Python functions. The following example demonstrates how to use `jax` to calculate the gradient of the log likelihood function in the additive Gaussian noise model. In the ilike file:

```{Rcpp,eval=FALSE}
/***evaluate_log_likelihood,my_log_llhd(parameters,data)***/

/***evaluate_gradient_log_likelihood,my_grad_log_llhd(variable,parameters,data)***/
```

and in the .py file:

```{python,eval=FALSE}
import jax.numpy as jnp
from jax.scipy.stats import norm
from jax import grad, jit
from functools import reduce
from jax import vmap

def logpdf_func(mu,datum):
  Sigma = 1.0
  mu = jnp.array(mu)
  return jit(norm.logpdf)(datum, mu, Sigma)

def log_llhd_core(mu,y):
  logp = jit(vmap(logpdf_func,(None,0), 0))(mu,y)
  return sum(logp)

def my_log_llhd(parameters,data):
  return log_llhd_core(parameters["mu"],data["y"])

def my_grad_log_llhd(variable,parameters,data):
  return numpy.array(jit(grad(log_llhd_core, argnums=0))(parameters["mu"],data["y"]))
```

## Julia functions {#julia}

The use of Julia functions in ilike is similar to that of R and Python functions. The function header must be specified in the same way as for R and Python functions, with the function type followed by a call to the Julia function. The Julia function itself is specified in a file with the same name as the ilike file, but with the `.jl` extension. Behind the scenes, the `JuliaCall` R package is used to make the Julia function callable from R, and hence from ilike.

The use of Julia functions is similar to the use of Python functions. They may be called directly from the function header just as R functions are, and again, code in the function header should be treated as R code, even if the function being called is a Julia function (so, for example, use `parameters$x` in this line to access variable `x` in the `parameters` object). Julia functions cannot be used with parallel inference algorithms.

For example, in this case, for variety, we will use a lognormal pdf function in the ilike file:

```{Rcpp,eval=FALSE}
/***evaluate_log_prior,my_dlnorm(parameters.tau,1,1,TRUE)***/
```

`my_dlnorm` is a Julia function, specified in the Julia file using

```{julia,eval=FALSE}
function my_dlnorm(tau,m,s,l)
  μ_for_mean(m1, σ) = log(m1) - σ^2/2
  d = LogNormal(μ_for_mean(m, s), s)
  if (l==true)
    logpdf(d,tau)
  else
    pdf(d,tau)
  end
end
```

Just as when calling a Python function, when passing an integer argument to a Julia function, the argument must be cast to an integer in the function header. For example, suppose the Julia function `my_rnorm` (used in the data function in this case) takes an integer argument `n`, then the function header would be:

```{Rcpp,eval=FALSE}
/***data,y=my_rnorm(100L)***/
```

(note the key point: using `100L` instead of `100`) with the Julia file containing:

```{julia,eval=FALSE}
function my_rnorm(n)
  d = Normal()
  rand(d, n)
end
```

Also in common with the Python interface, there is an overhead to calling Julia functions from ilike. This overhead is even more computationally costly than calling Python functions. Therefore, it is recommended to use Julia functions only when necessary.

When using Julia functions, the directory containing the Julia bin file must be specified when `compile` is called. Further, when using Julia functions that rely on external packages the package should be listed in the `julia_required_libraries` argument when calling the `compile` function. For example:

```{r,eval=FALSE}
model = compile("myfile.ilike",
                julia_bin_dir = "/path/to/julia/bin",
                julia_required_libraries = c("Distributions"))
```

## ilike functions {#ilike-functions}

ilike contains a number of built-in functions that, under the hood, call C++ code contained in the ilike package. These functions are the only way of specifying some options in the ilike inference engine, and may also be used to specify parts of the model and/or algorithm. The functions are called in the ilike file in the same way as R, Python, and Julia functions, with the function type followed by a call to the function. For example, to specify the number of iterations in the MCMC algorithm, the `ilike::iterations` function is used:

```{Rcpp,eval=FALSE}
/***mcmc_termination,ilike::iterations(100000)***/
```

Other uses for ilike functions include specifying the proposal in an MCMC algorithm, or the prior distribution for a parameter. ilike functions also allow access to some key algorithms in ilike, for example approximate Bayesian computation (ABC). Documentation of all available ilike functions can be found in the following sections.

All ilike functions must include the prefix `ilike::` to distinguish them from a call to an R, Python or Julia function. ilike functions only have inputs, and do not return any values. The input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted.



<!-- Figures and tables with captions will be placed in `figure` and `table` environments, respectively. -->

<!-- ```{r nice-fig, fig.cap='Here is a nice figure!', out.width='80%', fig.asp=.75, fig.align='center'} -->
<!-- par(mar = c(4, 4, .1, .1)) -->
<!-- plot(pressure, type = 'b', pch = 19) -->
<!-- ``` -->

<!-- Reference a figure by its code chunk label with the `fig:` prefix, e.g., see Figure \@ref(fig:nice-fig). Similarly, you can reference tables generated from `knitr::kable()`, e.g., see Table \@ref(tab:nice-tab). -->

<!-- ```{r nice-tab, tidy=FALSE} -->
<!-- knitr::kable( -->
<!--   head(iris, 20), caption = 'Here is a nice table!', -->
<!--   booktabs = TRUE -->
<!-- ) -->
<!-- ``` -->

<!-- You can write citations, too. For example, we are using the **bookdown** package [@R-bookdown] in this sample book, which was built on top of R Markdown and **knitr** [@xie2015]. -->
