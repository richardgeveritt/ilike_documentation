# Models {#models}

The section describes how to specify a model in an ilike file. A model is specified through factors, the product of which defines a (possibly unnormalised) joint distribution^[The compiler makes no checks as to whether the factors provided define a valid joint distribution: responsibility for this is left to the user.]. In most situations we envisage users will be using ilike to perform inference conditional on observed data: in these cases the use must specify a function for ilike to load the data.

Factors can either be of the type **prior** or **likelihood**.

- A prior factor is any distribution that does not depend on observed data. Conditional distributions where none of the variables are observed would fall under this category.

- A likelihood factor is a distribution where one or more of the variables involved is observed.

To illustrate the distinction, consider a hierarchical model of the form

$$
p(\phi) f(\theta \mid \phi) g(y \mid \theta).
$$
If we wish to perform inference on $\theta$ and $\phi$ given observed $y$, then $p(\phi)$ and $f(\theta \mid \phi)$ would be specified as prior factors, and $g(y \mid \theta)$ would be specified as a likelihood factor. If, for whatever reason, we wished to construct, say, an MCMC algorithm for simulating from the joint distribution on $\phi$, $\theta$ and $y$, then all three could be specified as "priors".

The specification of a state-space model, which involves a time index $t$ and requires the specification of a transition model, is not described in this section: these details can be found in section \@(ssm).

There are two ways of specifying priors: through user-defined functions, or through (currently a fairly limited choice of) simple built-in "ilike" functions. For a likelihood, the specification through user-defined functions closely follows the analogous way of specifying a prior. The built-in choices of likelihood can be categorised as follows:

- linear and non-linear Gaussian models, covering the special case of measurements with Gaussian noise;

- simulated-based likelihoods, allowing the use of data models that are specified in the form of a simulator;

- algorithmic likelihoods, where the likelihood is given by an algorithm such as a particle filter.

Recall that every entry in an ilike file has a "function type". This section details every function type that may be used to specify a model: each subsubsection (e.g. 3.1.1) is named after a function type. For user-defined function types we detail the input and output arguments of the function, and give an example of its use. The specification of each function type is described in both C++ and R. Python and Julia function are both called from R - see section \@ref(ilike-files) - so do not require further description). For built-in (ilike) function types, we detail each available built-in function in subsubsubsubections (e.g. 3.2.1.1).

The order in which the factors are provided in the ilike file does not matter, but the compiler will allocate a number to each in the order they are provided, starting from 1. Some parts of the algorithm specification (e.g. specifying which factors must be evaluated in a Metropolis-Hastings update) require the user to refer to factors by their number, so the user may wish to use comments in the ilike file (through the C++ commenting style, i.e. `//` or `/* */`) to keep track of the factor numbers.

## Data

### data

The `data` function type returns observed data. There are no input arguments.

Output: The observed data.

  -- of class `Data` in a C++ function
  
  -- an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an `=` sign in the function header.
  
C++ example:

```{Rcpp,eval=FALSE}
/***data***/
Data set_data()
{
  arma::colvec y(2,1);
  y[0] = 1.0;
  y[1] = 2.0;
  return Data("y", y);
}
```

R example:

```{Rcpp,eval=FALSE}
/***data,y=c(1,2)***/
```

## User-defined prior

A user-defined prior is specified through some combination of function types (e.g. `evaluate_log_prior`, `simulate_prior`). The user only needs to specify the function types required by the algorithm they wish to use. For example:

  -- `evaluate_log_prior` for Metropolis-Hastings where the prior needs to be evaluated in the acceptance ratio;
  
  -- `simulate_prior` for importance sampling where the prior is used as the proposal, and the prior cancels and does not need to be evaluated in the weight update;
  
  -- `evaluate_gradient_log_prior` for an unadjusted Langevin MCMC which requires the gradient of the prior to make moves.

We now describe the available function types.

### evaluate_log_prior

The `evaluate_log_prior` function type calculates the log prior density of the parameters.

Input: The point at which the log of the prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function

Output: The log prior density of the parameters.

  -- of type `double` in a C++ function
  
  -- of type `numeric` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_log_prior***/
double prior_eval(const Parameters &parameters)
{
  return dnorm(parameters["θ"][0]);
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_log_prior,dnorm(parameters$θ,log=TRUE)***/
```

### simulate_prior

The `simulate_prior` function type samples from the prior distribution.

Input: (C++ only) The random number generator.

  -- of type `RandomNumberGenerator &` in a C++ function

Output: The simulated value.

  -- of class `Parameters` in a C++ function
  
  -- an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an `=` sign in the function header.
  
C++ example:

```{Rcpp,eval=FALSE}
/***simulate_prior***/
Parameters prior_sim(RandomNumberGenerator &rng)
{
  return Parameters("θ",rnorm(rng));
}
```

R example:

```{Rcpp,eval=FALSE}
/***simulate_prior,θ=rnorm(1)***/
```

### evaluate_gradient_log_prior

The `evaluate_gradient_log_prior` function type gives the differential of the log prior density of the parameters.

Input: The variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable` in an R function

Input: The point at which the gradient of the log prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The gradient of the log prior density of the parameters.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_prior***/
arma::mat prior_gradient_eval(const std::string &variable,
                              const Parameters &parameters)
{
  if (variable=="θ")
  {
    arma::mat grad(1,1);
    grad(0,0) = -parameters["θ"][0];
    return grad;
  }
  else
  {
    Rcpp::stop("Unknown variable in prior gradient.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_prior,if (variable=="θ") {-parameters$θ} else {stop("Unknown variable in prior gradient.")}***/
```

### evaluate_second_gradient_log_prior

The `evaluate_gradient_log_prior` function type gives the second differential of the log prior density of the parameters.

Input: The first variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable1` in an R function
  
Input: The second variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable2` in an R function

Input: The point at which the gradient of the log prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The Hessian of the log prior density, evaluated at the given point.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_prior***/
arma::mat prior_gradient_eval(const std::string &variable1,
                              const std::string &variable2,
                              const Parameters &parameters)
{
  if ((variable1=="θ") && (variable2=="θ"))
  {
    arma::mat grad(1,1);
    grad(0,0) = -1.0;
    return grad;
  }
  else
  {
    Rcpp::stop("Unknown variable in prior second gradient.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_prior,if ((variable1=="θ") && (variable2=="θ")) {-1} else {stop("Unknown variable in prior second gradient.")}***/
```

## Built-in prior {#ilike-prior}

### prior (ilike functions)

The `prior` function type allows the user to specify the prior through an ilike function (e.g. `ilike::norm`). For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted.

Example of the use of one of these functions (`ilike::norm`) follows.

```{Rcpp,eval=FALSE}
/***prior,ilike::norm(θ,0,1)***/
```

The following sections detail the available ilike functions.

#### Normal prior `ilike::norm`

Specifies a normal prior over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric: the mean of the normal distribution
    
  3. numeric: the standard deviation of the normal distribution
  
#### Multivariate normal prior `ilike::mvnorm`

Specifies a multivariate normal prior over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric vector/matrix: the mean of the multivariate normal distribution
    
  3. matrix: the covariance of the multivariate normal distribution
   
#### Lognormal prior `ilike::lnorm`
    
Specifies a lognormal prior over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric: the mean of the log of the variable
    
  3. numeric: the standard deviation of the log of the variable
    
#### Multivariate lognormal prior `ilike::mvlnorm`

Specifies a multivariate loggnormal prior over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric vector/matrix: the mean of the log of the variable
    
  3. matrix: the covariance of the log of the variable

#### Gamma prior `ilike::gamma`
    
Specifies a gamma prior over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric: the shape of the gamma distribution
    
  3. numeric: the rate of the gamma distribution

## User-defined likelihood

The functions in this section allow the specification of a user-defined likelihood. Only the functions required by the chosen inference algorithm need be specified.

### evaluate_log_likelihood

The `evaluate_log_likelihood` function type calculates the log likelihood of the parameters.

Input: The point at which the log likelihood is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
 Input: The observed data for which the log likelihood is to be evaluated.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function

Output: The log likelihood of the parameters using the observed data.

  -- of type `double` in a C++ function
  
  -- of type `numeric` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_log_likelihood***/
double likelihood_eval(const Parameters &parameters,
                       const Data &data)
{
  double y = data["y"];
  return sum(dnorm(y,parameters["θ"][0],1.0));
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_log_likelihood,sum(dnorm(data$y,parameters$θ,1.0,log=TRUE))***/
```

### evaluate_gradient_log_likelihood

The `evaluate_gradient_log_likelihood` function type calculates the gradient of the log likelihood of the parameters.

Input: The variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable` in an R function
  
Input: The point at which the gradient of the log likelihood is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Input: The observed data for which the gradient of the log likelihood is to be evaluated.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function

Output: The gradient of the log likelihood of the parameters.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_likelihood***/
arma::mat likelihood_gradient_eval(const std::string &variable,
                                   const Parameters &parameters,
                                   const Data &data)
{
  if (variable=="θ")
  {
    arma::colvec y = data["y"];
    arma::mat grad(1,1);
    grad(0,0) = arma::sum((y-parameters["θ"][0])/1.0);
    return grad;
  }
  else
  {
    Rcpp::stop("Unknown variable in likelihood gradient.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_likelihood,if (variable=="θ") {sum((data$y-parameters$θ)/1.0)} else {stop("Unknown variable in likelihood gradient.")}***/
```

### evaluate_second_gradient_log_likelihood

The `evaluate_gradient_log_prior` function type gives the second differential of the log likelihood of the parameters.

Input: The first variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable1` in an R function
  
Input: The second variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable2` in an R function
  
Input: The point at which the gradient of the log prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The Hessian of the log likelihood, evaluated at the given point.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R.

C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_likelihood***/
arma::mat likelihood_hessian_eval(const std::string &variable1,
                                  const std::string &variable2,
                                  const Parameters &parameters,
                                  const Data &data)
{
  if (variable1=="θ" && variable2=="θ")
  {
    arma::mat hess(1,1);
    hess(0,0) = -data["y"].size()/1.0;
    return hess;
  }
  else
  {
    Rcpp::stop("Unknown variable in likelihood hessian.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_likelihood,if (variable1=="θ" && variable2=="θ") {-length(data$y)/1.0} else {stop("Unknown variable in likelihood hessian.")}***/
```

## Linear-Gaussian model

A commonly-used class of model is one where data $y$ arises from a linear function of some latent state, plus some Gaussian noise, i.e.

$$
y \sim \mathcal{MVN}(H x, R)
(\#eq:lgdm)
$$
where $H$ is a matrix and $R$ is a covariance matrix. The linear-Gaussian data model subtype allows the specification of such model, through providing the variable names ($y$ and $x$ here) and the values for $H$ and $R$. Note that, using this block subtype, it would be possible to specify a model for a number of independent observations from a Gaussian distribution. However, this would be an inefficient way of specifying this model since it would require the user to supply a large diagonal covariance matrix. Such a model would be more effectively specified via the exact_likelihood block sutype.

There are two ways of specifying a linear-Gaussian data model:

1. Through the function types `linear_gaussian_data_variable` (specifying the name of the $y$ variable), `linear_gaussian_data_state_variable` (specifying the name of the $x$ variable), `linear_gaussian_data_matrix` (specifying the $A$ matrix), and `linear_gaussian_data_covariance` (specifying the name of the $\Sigma$ matrix), The user needs to provide **all** of these functions in order to fully specify the model.

2. Through the function type `linear_gaussian_data_model`, which allows the user to specify the complete model through an ilike function.

We now detail the function types.

### linear_gaussian_data_variable

Specifies the name of the observed data variable in the linear-Gaussian data model. There are no input arguments.

Output: The name of the variable used as $y$ in equation \@ref(eq:lgdm).

  -- of type `const std::string &` in a C++ function
  
  -- a string in R.

C++ example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_variable***/
std::string set_data_variable()
{
  return "y";
}
```

R example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_variable,"y"***/
```

### linear_gaussian_data_state_variable

Specifies the name of the latent state variable in the linear-Gaussian data model. There are no input arguments.

Output: The name of the variable used as $x$ in equation \@ref(eq:lgdm).

  -- of type `const std::string &` in a C++ function
  
  -- a string in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_state_variable***/
std::string set_state_variable()
{
  return "x";
}
```

R example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_state_variable,"x"***/
```

### linear_gaussian_data_matrix

Specifies the matrix $A$ in the linear-Gaussian data model.

Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function

Output: The matrix $A$ in equation \@ref(eq:lgdm).

  -- of type `arma::mat` in a C++ function
  
  -- a matrix in R.
  
C++ examples:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_matrix***/
arma::mat set_matrix()
{
  arma::mat A(2,2);
  A(0,0) = 1.0;
  A(0,1) = 0.0;
  A(1,0) = 0.0;
  A(1,1) = 1.0;
  return A;
}
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_matrix***/
arma::mat set_matrix(const Parameters &parameters)
{
  double scale = parameters["scale"][0];
  arma::mat A(2,2);
  A(0,0) = scale;
  A(0,1) = 0.0;
  A(1,0) = 0.0;
  A(1,1) = scale;
  return A;
}
```

R example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_matrix,diag(2)***/
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_matrix,parameters$scale*diag(2)***/
```

### linear_gaussian_data_covariance

Specifies the covariance matrix $R$ in the linear-Gaussian data model.

Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The covariance matrix $R$ in equation \@ref(eq:lgdm).

  -- of type `arma::mat` in a C++ function
  
  -- a matrix in R
 
C++ examples:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_covariance***/
arma::mat set_covariance()
{
  arma::mat R(2,2);
  R(0,0) = 1.0;
  R(0,1) = 0.0;
  R(1,0) = 0.0;
  R(1,1) = 1.0;
  return R;
}
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_covariance***/
arma::mat set_covariance(const Parameters &parameters)
{
  double scale = parameters["scale"][0];
  arma::mat R(2,2);
  R(0,0) = scale;
  R(0,1) = 0.0;
  R(1,0) = 0.0;
  R(1,1) = scale;
  return R;
}
```
 
R examples:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_covariance,diag(2)***/
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_covariance,parameters$scale*diag(2)***/
```

### linear_gaussian_data_model (ilike function)

We may use an ilike function to specify the complete linear-Gaussian data model.

#### Linear-Gaussian data model `ilike::linear_gaussian_data_model`

Specifies the linear-Gaussian data model.

Inputs:

  1. string: The name of the observed data variable
  
  2. string: The name of the latent state variable
  
  3. matrix: The matrix $A$
  
  4. matrix: The covariance matrix $R$
  
## Nonlinear-Gaussian model

The nonlinear-Gaussian data model subtype may be used to specify a model where data $y$ arises from a nonlinear function of some latent state, plus some Gaussian noise, i.e.

$$
y \sim \mathcal{N}(g(x), R)
(\#eq:nlgdm)
$$
where $g$ is a function and $R$ is a covariance matrix. To specify the model we need to provide the variable name ($y$), the function $g$ and the matrix $R$. To do this the user must provide three function types, respectively: `nonlinear_gaussian_data_variable`, `nonlinear_gaussian_data_function` and `nonlinear_gaussian_data_covariance`.

### nonlinear_gaussian_data_variable

Specifies the name of the observed data variable. There are no input arguments.

Output: The name of the observed data variable.

  -- of type `const std::string &` in a C++ function
  
  -- a string in R.

C++ example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_variable***/
std::string set_variable()
{
  return "y";
}
```

R example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_variable,"y"***/
```

### nonlinear_gaussian_data_function

Specifies the function $g$ in the nonlinear-Gaussian data model.

Input: The state $x$ and any parameters that the function relies on (the latter may be included to allow the specification of a parameter-dependent function)

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The output of the function $g$ in equation \@ref(eq:nlgdm).

  -- of type `const Data &` in a C++ function
  
  -- a list in R.

C++ example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_function***/
Data transform_into_data_space(const Parameters &x_and_theta)
{
  arma::colvec noiseless_y(1,1);
  noiseless_y[0] = exp(x_and_theta["x"][0) + x_and_theta["theta"][0];
  return Data("y", noiseless_y);
}
```

R example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_function,y=exp(parameters$x)+parameters$theta***/
```

### nonlinear_gaussian_data_covariance

Specifies the covariance matrix $R$ in the nonlinear-Gaussian data model.

Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The covariance matrix $R$ in equation \@ref(eq:nlgdm).

  -- of type `arma::mat` in a C++ function
  
  -- a matrix in R.
  
C++ examples:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_covariance***/
arma::mat set_covariance()
{
  arma::mat R(2,2);
  R(0,0) = 1.0;
  R(0,1) = 0.0;
  R(1,0) = 0.0;
  R(1,1) = 1.0;
  return R;
}
```

or

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_covariance***/
arma::mat set_covariance(const Parameters &parameters)
{
  double scale = parameters["scale"][0];
  arma::mat R(2,2);
  R(0,0) = scale;
  R(0,1) = 0.0;
  R(1,0) = 0.0;
  R(1,1) = scale;
  return R;
}
```
 
R examples:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_covariance,diag(2)***/
```

or

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_covariance,parameters$scale*diag(2)***/
```

## Simulation-based likelihood

The functions in this section allow the specification of a likelihood through a function that simulates a data generating process, for example through approximate Bayesian computation. There are three function types that are required to be specified for all simulation-based likelihoods:

- `simulate_data_model`, which simulates the data generating process.

- `data_variable`, which specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation.

- `sbi_likelihood`, which uses an ilike function to define the desired simulation-based likelihood.

It is also possible to reduce the observed data to summary statistcs (though the use of the `summary_statistics` function type) for use in the simulation-based likelihood.

### simulate_data_model

The `simulate_data_model` function type simulates the data generating process.

Input: (C++ only) The random number generator to be used in the simulation.

  -- of type `RandomNumberGenerator &` in a C++ function

Input: The parameters at which to simulate the data.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function

Output: The simulated data.

  -- of class `Data` in a C++ function
  
  -- an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an `=` sign in the function header.
  
C++ example:

```{Rcpp,eval=FALSE}
/***simulate_data_model***/
Data simulate_data_model(RandomNumberGenerator &rng,
                         const Parameters &parameters)
{
  arma::colvec y = rnorm(rng,100,parameters["θ"][0],1.0);
  return Data("y", y);
}
```

R example:

```{Rcpp,eval=FALSE}
/***simulate_data_model,y=rnorm(100,parameters$θ,1)***/
```

### data_variable

The `data_variable` function type specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. There are no input arguments.

Output: The variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. To specify multiple output variables they must be separated by a semi-colon (with no spaces).

  -- of type `const std::string &` in a C++ function
  
  -- a string in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***data_variable***/
std::string a_variable()
{
  return "y"; // could be "y;z" for variables y and z
}
```

R example:

```{Rcpp,eval=FALSE}
/***data_variable,"y"***/
```

### summary_statistics

The `summary_statistics` function type reduces the observed data to summary statistics for use in the simulation-based likelihood. The inclusion of this function type is optional: if it is included, then inference using the simulation-based likelihood will be conditional only on the summary statistics of the data, rather than the full data. If the argument is omitted, the simulation-based likelihood will use the full data.

Input: Simulated/observed data.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function
  
Output: The summary statistics of the data.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function
  
C++ example:

```{Rcpp,eval=FALSE}
/***summary_statistics***/
Data summary_statistics(const Data &data)
{
  arma::colvec y = data["y"];
  return Data("y_mean", arma::mean(y));
}
```

R example:

```{Rcpp,eval=FALSE}
/***summary_statistics,y_mean=mean(data$y)***/
```

### sbi_likelihood (ilike functions)

The `sbi_likelihood` function type uses an ilike function to define the desired simulation-based likelihood. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted.

Example of the use of one of these functions (`ilike::sl`) follows.

```{Rcpp,eval=FALSE}
/***sbi_likelihood,ilike::sl(50)***/
```

All of these methods use simulations from the data generating process (DGP) to construct an approximate likelihood from data $y_{\mbox{obs}}$. $s_{\mbox{obs}}$ is used to denote the result of applying the `summary_statistic` function to $y_{\mbox{obs}}$. Let $y^{1:M}$ be $M$ draws from the DGP $f(\cdot \mid \theta)$ for parameter $\theta$ and let $s^{1:M}$ be the result of applying the `summary_statistic` function to each corresponding simulation. Suppose that each summary statistic lies in $\mathbb{R}^{d_s}$: this vector is the result of stacking the summary statistics named in the `data_variable` function type.

The available ilike functions are detailed in the following sections.

#### Synthetic likelihood `ilike::sl` {#sl}

Specifies a synthetic likelihood (SL), as described in @wood2010statistical and @price2018bayesian. The synthetic likelihood $l(s_{\mbox{obs}} \mid \theta)$ is given by

$$
l(s_{\mbox{obs}} \mid \theta) = \mathcal{MVN}\left( s_{\mbox{obs}} \mid \hat{\mu}, \hat{\Sigma} \right),
(\#eq:sl)
$$ where
$$
\hat{\mu} = \frac{1}{M} \sum_{j=1}^M s^{j} \qquad \hat{\Sigma} = \frac{1}{M-1} \sum_{j=1}^M \left( s^{j} - \hat{\mu} \right) \left( s^{j} - \hat{\mu} \right)^T.
(\#eq:slmusigma)
$$ @price2018bayesian describes an extended version of this approach, which uses an unbiased estimate of the Gaussian distribution in equation \@ref(eq:sl), also based on $\hat{\mu}$ and $\hat{\Sigma}$ from equation \@ref(eq:slmusigma).

Inputs:

  1. integer: the number of simulations $M$ to use in the synthetic likelihood
  
  2. (optional) boolean: whether to use the unbiased version of synthetic likelihood described in @price2018bayesian (default is `false`)
  
  3. (optional) boolean: whether to store the output of the model simulations (default is `false`)
  
  4. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  5. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))
  
#### ABC (uniform kernel; Euclidean distance) `ilike::euclidean_uniform_abc`

Specifies an approximate Bayesian computation (ABC), using a uniform kernel and Euclidean distance metric, as described in @sisson2018handbook. The `euclidean_uniform_abc` likelihood $l(s_{\mbox{obs}} \mid \theta)$ is given, for tolerance level $\epsilon$, by

$$
l(s_{\mbox{obs}} \mid \theta) = \frac{1}{M}\sum_{j=1}^{M}K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right)
$$
where
$$
K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right) = \begin{cases} 1/c & \text{if } d( s_{\mbox{obs}} - s^{j} ) \leq \epsilon \\ 0 & \text{otherwise} \end{cases},
$$
for

$$
c = \frac{2^{d_s}\Gamma\left(\frac{1}{2}+1\right)^{d_s}}{\Gamma\left(\frac{d_s}{2}+1\right)}\epsilon^{d_s}\sum_{i=1}^{d_s}\sigma_{i}
$$
where

$$
d(s_{\text{obs}},s)=\left(\sum_{i=1}^{d_{s}}\left(\frac{s_{\text{obs},i}-s_{i}}{\sigma_{i}}\right)^{2}\right)^{1/2}
$$

Here $\sigma_i$ is a scaling used for the $i$th dimension of $s$. The value of $c$ is here to ensure that the uniform kernel is normalised, and uses the [formula for volume of a $d_s$-dimensional ball](https://www.johndcook.com/blog/2010/07/02/volumes-of-generalized-unit-balls/).

Inputs:

  1. integer: the number of simulations $M$ to use in the ABC
  
  2. string: the name of the tolerance variable in the ABC
  
  3. numeric: the tolerance level for the ABC
  
  4. (optional) string: the name of the variable that stores the scaling $\sigma_i$ of the data/summaries in the ABC (default is `""` - in this case the scale will be `1` for every dimension)
  
  5. (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 4) is set.
  
  6. (optional) boolean: whether to store the output of the model simulations (default is `false`)
  
  7. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  8. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))

#### ABC (uniform kernel; $L^p$ distance) `ilike::lp_uniform_abc`

Specified an approximate Bayesian computation (ABC) likelihood, using a uniform kernel and the $L^p$ distance metric. The `lp_uniform_abc` likelihood $l(y \mid \theta)$ is given, for tolerance level $\epsilon$, by

$$
l(s_{\mbox{obs}} \mid \theta) = \frac{1}{M}\sum_{j=1}^{M}K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right)
$$
where
$$
K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right) = \begin{cases} 1/c & \text{if } d( s_{\mbox{obs}} - s^{j} ) \leq \epsilon \\ 0 & \text{otherwise} \end{cases},
$$
for

$$
c = \frac{2^{d_s}\Gamma\left(\frac{1}{p}+1\right)^{d_s}}{\Gamma\left(\frac{d_s}{p}+1\right)}\epsilon^{d_s}\sum_{j=1}^{d_s}\sigma_{i}
$$
where

$$
d(s_{\text{obs}},s)=\left(\sum_{i=1}^{d_{s}}\left(\frac{s_{\text{obs},i}-s_{i}}{\sigma_{i}}\right)^{p}\right)^{1/p}
$$

Here $\sigma_i$ is a scaling used for the $i$th dimension of $s$. The value of $c$ is here to ensure that the uniform kernel is normalised, and uses the [formula for volume of a $d_s$-dimensional ball in $L^p$ space](https://www.johndcook.com/blog/2010/07/02/volumes-of-generalized-unit-balls/).

Inputs:

  1. integer: the number of simulations $M$ to use in the ABC
  
  2. string: the name of the tolerance variable in the ABC
  
  3. numeric: the tolerance level for the ABC
  
  4. numeric: the value of $p$ for the $L^p$ distance metric
  
  5. (optional) string: the name of the variable that stores the scaling $\sigma_i$ of the data/summaries in the ABC (default is `""` - in this case the scale will be `1` for every dimension)
  
  6. (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 5) is set.
  
  7. (optional) boolean: whether to store the output of the model simulations (default is `false`)
  
  8. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  9. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))

#### ABC (Gaussian kernel) `ilike::gaussian_abc` {#gaussian-abc}

Specifies an approximate Bayesian computation (ABC) likelihood, using a Gaussian kernel. The `gaussian_abc` likelihood $l(s_{\mbox{obs}} \mid \theta)$ is given, for tolerance level $\epsilon$, by

$$
l(s_{\mbox{obs}} \mid \theta) = \frac{1}{M}\sum_{j=1}^{M}K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right)
$$
where
$$
K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right) = \left(2\pi\epsilon\right)^{-d_{y}/2}\prod_{i=1}^{d_{s}}\frac{1}{\sigma_{i}^{2}}\exp\left(-\frac{1}{2\epsilon^{2}}\sum_{i=1}^{d_{s}}\left(\frac{s_{\text{obs},i}-s_{i}}{\sigma_{i}}\right)^{2}\right).
$$
Here $\sigma_i$ is a scaling used for the $i$th dimension of $s$.

Inputs:

  1. integer: the number of simulations $M$ to use in the ABC
  
  2. string: the name of the tolerance variable in the ABC
  
  3. numeric: the tolerance level for the ABC
  
  4. (optional) string: the name of the variable that stores the scaling $\sigma_i$ of the data/summaries in the ABC (default is `""` - in this case the scale will be `1` for every dimension)
  
  5. (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 4) is set.
  
  6. (optional) boolean: whether to store the output of the model simulations (default is `false`)
  
  7. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  8. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))
  
#### IEnKI-ABC `ilike::ienki_abc`

Specifies an approximate Bayesian computation (ABC) likelihood, estimating using iterative ensemble Kalman inversion (IEnKI), as described in @everitt2024ensemble. This approach uses an alternative estimator for the ABC likelihood using the Gaussian kernel, with tolerance $\epsilon$, described in section \@ref(gaussian-abc). IEnKI uses an ensemble of points to simulate from a sequence of $0:T$ distributions using a decreasing sequence of tolerances $\infty = \epsilon_0 > .... > \epsilon_T = \epsilon$. The 0th distrbution is $f_s( s \mid \theta)$ (corresponding to the case where $\epsilon=\infty$), where $f_s$ is the distribution resulting from the data generating process $f( \cdot \mid \theta)$ and the summary statistic transformation. The $t$th distribution for $t>0$ is $f_s( s \mid \theta) K_{\epsilon_t}\left(s_{\text{obs}}\mid s\right)$. The estimator of the normalising constant of the final target distribution, constructed using the ensemble at each step of the IEnKI, is an estimator of the ABC likelihood. This estimator is biased in general, but is likely to have significantly lower variance than that from standard ABC. When the final $\epsilon$ is taken to be zero, and $T=1$, the estimator is the same as that used in synthetic likelihood (section \@ref(sl)). Full details can be found in @everitt2024ensemble.

Inputs:

  1. integer: the number of ensemble members $M$ to use in the IEnKI-ABC
  
  2. integer: the estimator type constructed from the IEnKI output. The meaning of each of the four options below is given in the paper @everitt2024ensemble. The options are:
  
  - `1` (recommended): the "direct" estimator
    
  - `2`: the "unbiased" estimator, using the approach analogous to the unbiased method in @price2018bayesian
    
  - `3`: the path sampling estimator
    
  - `4`: the alternative path sampling estimator from @friel2014improving
  
  3. string: the name of the tolerance variable in the ABC
  
  4. numeric: the tolerance level for the ABC
  
  5. string: the shifter used in the IEnKI (the method for moving the ensemble at each iteration). The options are:
  
  - `stochastic` (recommended): the stochastic shifter
  
  - `sqrt`: the square root shifter
  
  - `adjustment`: the adjustment shifter
  
  6. integer: the number of targets $T$ used in the IEnKI
  
  7. (optional) numeric: the significance level for the significance test used in determining when to use the target skipping approach proposed in @everitt2024ensemble (default is `1`, which results in skipping no targets; `0.1` recommended when using the stochastic shifter)
  
  8. (optional) integer: the number of iterations of output of each run of the IEnKI to store, counting from the final iteration backwards (default is `0`)
  
  9. (optional) string: the name of the variable that stores the scaling $\sigma_i$ of the data/summaries in the ABC (default is `""` - in this case the scale will be `1` for every dimension)
  
  10. (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 5) is set.
  
  11. (optional) boolean: whether to perform the IEnKI on the summary statistic space (default is `true`; `false` is largely untested)
  
  12. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  13. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))

## Algorithmic likelihood

For some models, the likelihood can be computed or estimated by running an algorithm. For example, the marginal likelihood of a state-space model may be estimated using a particle filter. To specify such a likelihood, the user must provide a function type `algorithmic_likelihood`, then use an ilike function to specify the type of likelihood.

### algorithmic_likelihood (ilike functions)

The likelihood function type allows the user to specify the likelihood through an ilike function. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted.

The available ilike functions are detailed in the following sections.

#### Kalman filter `ilike::kf`

The Kalman filter (KF) is a recursive algorithm that estimates the state of a linear Gaussian state-space model and, in this context, can be used to calculate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running a KF from the ilike R package as described in section \@ref(kf).

Inputs:

  1. string: The name of an ilike file (with extension) that contains the specification of a linear-Gaussian state-space model and the required ilike function for setting up a filter, as described in section \@ref(filter). A full description of what is required in the file is given in section \@ref(kf).
  
  2. (optional) integer: THe number of iterations output of the KF to store, counting from the final iteration backwards (default is `0`)
  
#### Particle filter `ilike::pf`

The particle filter is a recursive algorithm that estimates the state of a general state-space model and, in this context, can be used to estimate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running a PF from the ilike R package as described in section \@ref(pf).

Inputs:

  1. string: The name of an ilike file (with extension) that contains the specification of a general state-space model and the required ilike function for setting up a filter, as described in section \@ref(filter). A full description of what is required in the file is given in section \@ref(pf).

  2. integer: The number of particles to use in the particle filter.
  
  3. (optional) integer: The number of iterations output of the PF to store, counting from the final iteration backwards (default is `0`).
  
  4. (optional) boolean: Whether to run the particle filter in parallel (default is `false`).
  
  5. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))
  
#### Ensemble Kalman filter `ilike::enkf`

The ensemble Kalman filter (EnKF) is a recursive algorithm that estimates the state of a general state-space model and, in this context, can be used to estimate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running an EnKF from the ilike R package as described in section \@ref(enkf).

Inputs:

  1. string: The name of an ilike file (with extension) that contains the specification of a general state-space model and the required ilike function for setting up a filter, as described in section \@ref(filter). A full description of what is required in the file is given in section \@ref(enkf).

  2. integer: The number of ensemble members to use in the EnKF.
  
  3. string: The name of the shifter to use in the EnKF (the method for moving the ensemble at each iteration). The options are:
  
  - `stochastic`: the stochastic shifter
  
  - `sqrt`: the square root shifter
  
  - `adjustment`: the adjustment shifter
  
  4. (optional) integer: The number of iterations output of the EnKF to store, counting from the final iteration backwards (default is `0`).
  
  5. (optional) boolean: Whether to run the EnKF in parallel (default is `false`).
  
  6. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))
