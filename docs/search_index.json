[["blocks.html", "Chapter 3 ilike blocks", " Chapter 3 ilike blocks This section details all block types (e.g. “factor”) and subtypes (e.g. “prior”), and all function types (e.g. “evaluate_log_prior”) available in ilike. Each subsection is devoted to a particular block type, with subsubsections being devoted to each function type. Each subsubsection details the input and output arguments of the function, and gives an example of its use. The specification of each function type is described in both C++ and R. Python and Julia function are both called from R - see section 2 - so do not require further description). The available block types, with subtypes, are as follows: factor. Factors of a joint distribution. – prior – exact likelihood – simulation-based likelihood – linear gaussian – non-linear Gaussian importance sampling proposal. An importance sampling proposal. – exact Metropolis proposal. A proposal for a Metropolis algorithm. – exact Metropolis-Hastings proposal. A proposal for a Metropolis-Hastings algorithm. – exact independent Metropolis-Hastings proposal. An independent proposal for a Metropolis-Hastings algorithm. – exact unadjusted proposal. A proposal used for MCMC moves without a Metropolis-Hastings acceptance correction. – exact transition model. The transition model in a state-space model. – exact – linear Gaussian – non-linear Gaussian transition proposal. The transition proposal for a particle filter. – exact – linear Gaussian – non-linear Gaussian data. Observed data. (no subtypes) method. Used to specify parameters for inference algorithms. (no subtypes) Recall, from 2.1, that the block type (and subtype) are determined by function types in the block. The block type (or subtype) does not need to be specified in the ilike file. We include these terms for the purposes of organising the documentation, and to help a user understand the output generated by compiling the ilike file should they wish to. "],["factor-blocks.html", "3.1 Factor blocks", " 3.1 Factor blocks 3.1.1 Prior There are two ways of specifying priors: Through some combination of function types (e.g. evaluate_log_prior, simulate_prior) defined below. The user only needs to specify the function types required by the algorithm they wish to use. For example: – evaluate_log_prior for Metropolis-Hastings where the prior needs to be evaluated in the acceptance ratio; – simulate_prior for importance sampling where the prior is used as the proposal, and the prior cancels and does not need to be evaluated in the weight update; – evaluate_gradient_log_prior for an unadjusted Langevin MCMC which requires the gradient of the prior to make moves. Through the function type prior, which allows the user to specify the prior through an ilike function (e.g. ilike::norm), which results in the specification of all of the other prior function types (i.e. evaluate_log_prior, simulate_prior, evaluate_gradient_log_prior and evaluate_second_gradient_log_prior are all specified by using ilike::norm). We now detail the function types available for specifying a prior. 3.1.1.1 evaluate_log_prior The evaluate_log_prior function type calculates the log prior density of the parameters. Input: The point at which the log of the prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The log prior density of the parameters. – of type double in a C++ function – of type numeric in R. C++ example: /***evaluate_log_prior***/ double prior_eval(const Parameters &amp;parameters) { return dnorm(parameters[&quot;θ&quot;][0]); } R example: /***evaluate_log_prior,dnorm(parameters$θ)***/ 3.1.1.2 simulate_prior The simulate_prior function type samples from the prior distribution. Input: (C++ only) The random number generator. – of type RandomNumberGenerator &amp; in a C++ function Output: The simulated value. – of class Parameters in a C++ function – an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an = sign in the function header. C++ example: /***simulate_prior***/ Parameters prior_sim(RandomNumberGenerator &amp;rng) { return Parameters(&quot;θ&quot;,rnorm(rng)); } R example: /***simulate_prior,θ=rnorm(1)***/ 3.1.1.3 evaluate_gradient_log_prior The evaluate_gradient_log_prior function type gives the differential of the log prior density of the parameters. Input: The variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable in an R function Input: The point at which the gradient of the log prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The gradient of the log prior density of the parameters. – of type arma::mat in a C++ function – of type matrix in R. C++ example: /***evaluate_gradient_log_prior***/ arma::mat prior_gradient_eval(const std::string &amp;variable, const Parameters &amp;parameters) { if (variable==&quot;θ&quot;) { arma::mat grad(1,1); grad(0,0) = -parameters[&quot;θ&quot;][0]; return grad; } else { Rcpp::stop(&quot;Unknown variable in prior gradient.&quot;); } } R example: /***evaluate_gradient_log_prior,if (variable==&quot;θ&quot;) {-parameters$θ} else {stop(&quot;Unknown variable in prior gradient.&quot;)}***/ 3.1.1.4 evaluate_second_gradient_log_prior The evaluate_gradient_log_prior function type gives the second differential of the log prior density of the parameters. Input: The first variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable1 in an R function Input: The second variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable2 in an R function Input: The point at which the gradient of the log prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The Hessian of the log prior density, evaluated at the given point. – of type arma::mat in a C++ function – of type matrix in R C++ example: /***evaluate_second_gradient_log_prior***/ arma::mat prior_gradient_eval(const std::string &amp;variable1, const std::string &amp;variable2, const Parameters &amp;parameters) { if ((variable1==&quot;θ&quot;) &amp;&amp; (variable2==&quot;θ&quot;)) { arma::mat grad(1,1); grad(0,0) = -1.0; return grad; } else { Rcpp::stop(&quot;Unknown variable in prior second gradient.&quot;); } } R example: /***evaluate_second_gradient_log_prior,if ((variable1==&quot;θ&quot;) &amp;&amp; (variable2==&quot;θ&quot;)) {-1} else {stop(&quot;Unknown variable in prior second gradient.&quot;)}***/ 3.1.1.5 prior The prior function type allows the user to specify the prior through an ilike function (e.g. ilike::norm), which results in the specification of all of the other prior function types. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Example of the use of one of these functions (ilike::norm) follows. /***prior,ilike::norm(θ,0,1)***/ The following ilike functions are available: ilike::norm: a normal prior. Inputs: string: the variable for which the prior is specified numeric: the mean of the normal distribution numeric: the standard deviation of the normal distribution ilike::mvnorm: a multivariate normal prior. Inputs: – string: the variable for which the prior is specified – numeric vector/matrix: the mean of the multivariate normal distribution – matrix: the covariance of the multivariate normal distribution ilike::lnorm: a lognormal prior. Inputs: – string: the variable for which the prior is specified – numeric: the mean of the log of the variable – numeric: the standard deviation of the log of the variable ilike::mvnorm: a multivariate loggnormal prior. Inputs: – string: the variable for which the prior is specified – numeric vector/matrix: the mean of the log of the variable – matrix: the covariance of the log of the variable ilike::gamma: a gamma prior. Inputs: – string: the variable for which the prior is specified – numeric: the shape of the gamma distribution – numeric: the rate of the gamma distribution 3.1.2 Exact likelihood The functions in this section allow the specification of a user-defined likelihood. Only the functions required by the chosen inference algorithm need be specified. Usually we recommend specifying, rather than a likelihood, the data model. This will ensure that, when running importance sampling for example, the normalising constant estimate returned by that algorithm will be an estimate of the marginal likelihood. However, where the goal is simulating from or approximating the posterior distribution, specifying the model up to proportionality is sufficient. 3.1.2.1 evaluate_log_likelihood The evaluate_log_likelihood function type calculates the log likelihood of the parameters. Input: The point at which the log likelihood is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Input: The observed data for which the log likelihood is to be evaluated. – of type const Data &amp; in a C++ function – available as R list data in an R function Output: The log likelihood of the parameters using the observed data. – of type double in a C++ function – of type numeric in R. C++ example: /***evaluate_log_likelihood***/ double likelihood_eval(const Parameters &amp;parameters, const Data &amp;data) { double y = data[&quot;y&quot;]; return sum(dnorm(y,parameters[&quot;θ&quot;][0],1.0)); } R example: /***evaluate_log_likelihood,sum(dnorm(data$y,parameters$θ,1.0))***/ 3.1.2.2 evaluate_gradient_log_likelihood The evaluate_gradient_log_likelihood function type calculates the gradient of the log likelihood of the parameters. Input: The variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable in an R function Input: The point at which the gradient of the log likelihood is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Input: The observed data for which the gradient of the log likelihood is to be evaluated. – of type const Data &amp; in a C++ function – available as R list data in an R function Output: The gradient of the log likelihood of the parameters. – of type arma::mat in a C++ function – of type matrix in R. C++ example: /***evaluate_gradient_log_likelihood***/ arma::mat likelihood_gradient_eval(const std::string &amp;variable, const Parameters &amp;parameters, const Data &amp;data) { if (variable==&quot;θ&quot;) { arma::colvec y = data[&quot;y&quot;]; arma::mat grad(1,1); grad(0,0) = arma::sum((y-parameters[&quot;θ&quot;][0])/1.0); return grad; } else { Rcpp::stop(&quot;Unknown variable in likelihood gradient.&quot;); } } R example: /***evaluate_gradient_log_likelihood,if (variable==&quot;θ&quot;) {sum((data$y-parameters$θ)/1.0)} else {stop(&quot;Unknown variable in likelihood gradient.&quot;)}***/ 3.1.2.3 evaluate_second_gradient_log_likelihood The evaluate_gradient_log_prior function type gives the second differential of the log likelihood of the parameters. Input: The first variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable1 in an R function Input: The second variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable2 in an R function Input: The point at which the gradient of the log prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The Hessian of the log likelihood, evaluated at the given point. – of type arma::mat in a C++ function – of type matrix in R. C++ example: /***evaluate_second_gradient_log_likelihood***/ arma::mat likelihood_hessian_eval(const std::string &amp;variable1, const std::string &amp;variable2, const Parameters &amp;parameters, const Data &amp;data) { if (variable1==&quot;θ&quot; &amp;&amp; variable2==&quot;θ&quot;) { arma::mat hess(1,1); hess(0,0) = -data[&quot;y&quot;].size()/1.0; return hess; } else { Rcpp::stop(&quot;Unknown variable in likelihood hessian.&quot;); } } R example: /***evaluate_second_gradient_log_likelihood,if (variable1==&quot;θ&quot; &amp;&amp; variable2==&quot;θ&quot;) {-length(data$y)/1.0} else {stop(&quot;Unknown variable in likelihood hessian.&quot;)}***/ 3.1.3 Simulation-based likelihood The functions in this section allow the specification of a likelihood through a function that simulates a data generating process, for example through approximate Bayesian computation. There are three function types that are required to be specified for all simulation-based likelihoods: simulate_data_model, which simulates the data generating process. data_variable, which specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. sbi_likelihood, which uses an ilike function to define the desired simulation-based likelihood. It is also possible to reduce the observed data to summary statistcs (though the use of the summary_statistics function type) for use in the simulation-based likelihood. 3.1.3.1 simulate_data_model The simulate_data_model function type simulates the data generating process. Input: (C++ only) The random number generator to be used in the simulation. – of type RandomNumberGenerator &amp; in a C++ function Input: The parameters at which to simulate the data. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The simulated data. – of class Data in a C++ function – an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an = sign in the function header. C++ example: /***simulate_data_model***/ Data simulate_data_model(RandomNumberGenerator &amp;rng, const Parameters &amp;parameters) { arma::colvec y = rnorm(rng,100,parameters[&quot;θ&quot;][0],1.0); return Data(&quot;y&quot;, y); } R example: /***simulate_data_model,y=rnorm(100,parameters$θ,1)***/ 3.1.3.2 data_variable The data_variable function type specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. There are no input arguments. Output: The variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. To specify multiple output variables they must be separated by a semi-colon (with no spaces). – of type const std::string &amp; in a C++ function – a string in R. C++ example: /***data_variable***/ std::string a_variable() { return &quot;y&quot;; // could be &quot;y;z&quot; for variables y and z } R example: /***data_variable,&quot;y&quot;***/ 3.1.3.3 sbi_likelihood The sbi_likelihood function type uses an ilike function to define the desired simulation-based likelihood. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted. Example of the use of one of these functions (ilike::sl) follows. /***sbi_likelihood,ilike::sl(50)***/ The following ilike functions are available: ilike::sl: Synthetic likelihood, as described in Wood (2010) and Price et al. (2018). Inputs: integer: the number simulations to use in the synthetic likelihood – (optional) boolean: whether to use the unbiased version of synthetic likelihood described in Price et al. (2018) (default is false) – (optional) boolean: whether to store the output of the model simulations (default is false) – (optional) boolean: whether to run the simulations in parallel (default is false) – (optional) integer: the grain size for parallelisation (default is 1) size_t number_of_points; bool unbiased; bool store_output; bool parallel; size_t grain_size; number_of_points = info[0]; unbiased = info[1]; store_output = info[2]; parallel = info[3]; grain_size = info[4]; References Price, Leah F, Christopher C Drovandi, Anthony Lee, and David J Nott. 2018. “Bayesian Synthetic Likelihood.” Journal of Computational and Graphical Statistics 27 (1): 1–11. Wood, Simon N. 2010. “Statistical Inference for Noisy Nonlinear Ecological Dynamic Systems.” Nature 466 (7310): 1102–4. "],["data-block.html", "3.2 Data block", " 3.2 Data block 3.2.1 Data 3.2.1.1 data The data function type returns observed data. There are no input arguments. Output: The observed data. – of class Data in a C++ function – an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an = sign in the function header. C++ example: /***data***/ Data set_data() { arma::colvec y(2,1); y[0] = 1.0; y[1] = 2.0; return Data(&quot;y&quot;, y); } R example: /***evaluate_log_prior,y=c(1,2)***/ prior_function_types = c(&quot;prior&quot;,&quot;evaluate_log_prior&quot;,&quot;simulate_prior&quot;,&quot;evaluate_gradient_log_prior&quot;,&quot;evaluate_second_gradient_log_prior&quot;) custom_likelihood_function_types = c(&quot;evaluate_log_likelihood&quot;,&quot;evaluate_gradient_log_likelihood&quot;,&quot;evaluate_second_gradient_log_likelihood&quot;) #file_likelihood_types = c(&quot;importance_sample&quot;,&quot;smc_mcmc_move&quot;) sbi_likelihood_function_types = c(&quot;simulate_data_model&quot;,&quot;sbi_likelihood&quot;,&quot;summary_statistics&quot;,&quot;data_variable&quot;) linear_gaussian_data_model_types = c(&quot;linear_gaussian_data_model&quot;,&quot;linear_gaussian_data_matrix&quot;,&quot;linear_gaussian_data_covariance&quot;,&quot;linear_gaussian_data_variable&quot;,&quot;linear_gaussian_data_state_variable&quot;) nonlinear_gaussian_data_model_types = c(&quot;nonlinear_gaussian_data_model&quot;,&quot;nonlinear_gaussian_data_function&quot;,&quot;nonlinear_gaussian_data_covariance&quot;,&quot;nonlinear_gaussian_data_variable&quot;) other_likelihood_function_types = c(&quot;likelihood&quot;) factor_function_types = c(prior_function_types,custom_likelihood_function_types,sbi_likelihood_function_types,linear_gaussian_data_model_types,nonlinear_gaussian_data_model_types,other_likelihood_function_types) ilike_transition_model_types = c(&quot;transition_model&quot;) linear_gaussian_transition_model_types = c(&quot;linear_gaussian_transition_model&quot;,&quot;linear_gaussian_transition_matrix&quot;,&quot;linear_gaussian_transition_covariance&quot;,&quot;linear_gaussian_transition_variable&quot;) nonlinear_gaussian_transition_model_types = c(&quot;nonlinear_gaussian_transition_model&quot;,&quot;nonlinear_gaussian_transition_function&quot;,&quot;nonlinear_gaussian_transition_covariance&quot;,&quot;nonlinear_gaussian_transition_variable&quot;) custom_transition_model_types = c(&quot;simulate_transition_model&quot;,&quot;evaluate_log_transition_model&quot;) transition_model_types = c(ilike_transition_model_types,linear_gaussian_transition_model_types,nonlinear_gaussian_transition_model_types,custom_transition_model_types) custom_potential_function_types = c(&quot;evaluate_log_potential_function&quot;) ilike_potential_function_types = c(&quot;potential_function&quot;) potential_function_types = c(custom_potential_function_types,ilike_potential_function_types) data_function_types = c(&quot;data&quot;) importance_proposal_types = c(&quot;simulate_importance_proposal&quot;,&quot;evaluate_log_importance_proposal&quot;,&quot;importance_proposal&quot;) mh_proposal_types = c(&quot;simulate_mh_proposal&quot;,&quot;evaluate_log_mh_proposal&quot;,&quot;mh_proposal&quot;,&quot;mh_transform&quot;,&quot;mh_inverse_transform&quot;,&quot;mh_transform_jacobian_matrix&quot;,&quot;mh_factor_index&quot;) unadjusted_proposal_types = c(&quot;simulate_unadjusted_proposal&quot;,&quot;unadjusted_proposal&quot;,&quot;unadjusted_transform&quot;,&quot;unadjusted_inverse_transform&quot;,&quot;unadjusted_transform_jacobian_matrix&quot;,&quot;unadjusted_factor_index&quot;) independent_mh_proposal_types = c(&quot;simulate_independent_mh_proposal&quot;,&quot;evaluate_log_independent_mh_proposal&quot;,&quot;independent_mh_proposal&quot;,&quot;independent_mh_transform&quot;,&quot;independent_mh_inverse_transform&quot;,&quot;independent_mh_transform_jacobian_matrix&quot;,&quot;independent_mh_factor_index&quot;) m_proposal_types = c(&quot;simulate_m_proposal&quot;,&quot;m_proposal&quot;,&quot;m_transform&quot;,&quot;m_inverse_transform&quot;,&quot;m_transform_jacobian_matrix&quot;,&quot;m_factor_index&quot;) transition_proposal_types = c(&quot;simulate_transition_proposal&quot;,&quot;evaluate_log_transition_proposal&quot;) enk_transform_types = c(&quot;enk_transform&quot;,&quot;enk_inverse_transform&quot;) #reinforce_gradient = c(&quot;reinforce_gradient&quot;) method_function_types = c(&quot;mcmc_weights&quot;,&quot;mcmc_termination&quot;,&quot;adaptive_resampling&quot;,&quot;adaptive_target&quot;,&quot;smc_termination&quot;,&quot;smc_sequence&quot;,&quot;reinforce_gradient&quot;,&quot;enk_likelihood_index&quot;,&quot;enk_shifter&quot;,&quot;filter&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
