[["blocks.html", "Chapter 3 ilike blocks", " Chapter 3 ilike blocks This section details all block types (e.g. “factor”) and subtypes (e.g. “prior”), and all function types (e.g. “evaluate_log_prior”) available in ilike. Each subsection is devoted to a particular block type (subtype), with subsections being devoted to each function type. Each subsection details the input and output arguments of the function, and gives an example of its use. The specification of each function type is described in both C++ and R. Python and Julia function are both called from R - see section 2 - so do not require further description). The available block types, with subtypes, are as follows: factor. Factors of a joint distribution. – prior – exact likelihood – simulation-based likelihood – linear gaussian data model – non-linear Gaussian data model importance sampling proposal. An importance sampling proposal. – exact Metropolis proposal. A proposal for a Metropolis algorithm. – exact Metropolis-Hastings proposal. A proposal for a Metropolis-Hastings algorithm. – exact independent Metropolis-Hastings proposal. An independent proposal for a Metropolis-Hastings algorithm. – exact unadjusted proposal. A proposal used for MCMC moves without a Metropolis-Hastings acceptance correction. – exact transition model. The transition model in a state-space model. – exact – linear Gaussian – non-linear Gaussian transition proposal. The transition proposal for a particle filter. – exact – linear Gaussian – non-linear Gaussian data. Observed data. (no subtypes) method. Used to specify parameters for inference algorithms. (no subtypes) Recall, from 2.1, that the block type (and subtype) are determined by function types in the block. The block type (or subtype) does not need to be specified in the ilike file. We include these terms for the purposes of organising the documentation, and to help a user understand the output generated by compiling the ilike file should they wish to. "],["factor-custom-prior.html", "3.1 Factor: custom prior", " 3.1 Factor: custom prior There are two ways of specifying priors: (a) through the user supplying functions such as evaluate_log_prior; (b) through the use of ilike functions giving pre-defined priors such as ilike::norm. This section describes (a), with (b) being described in section 3.2. A custom prior is specified through some combination of function types (e.g. evaluate_log_prior, simulate_prior). The user only needs to specify the function types required by the algorithm they wish to use. For example: – evaluate_log_prior for Metropolis-Hastings where the prior needs to be evaluated in the acceptance ratio; – simulate_prior for importance sampling where the prior is used as the proposal, and the prior cancels and does not need to be evaluated in the weight update; – evaluate_gradient_log_prior for an unadjusted Langevin MCMC which requires the gradient of the prior to make moves. We now describe the available function types. 3.1.1 evaluate_log_prior The evaluate_log_prior function type calculates the log prior density of the parameters. Input: The point at which the log of the prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The log prior density of the parameters. – of type double in a C++ function – of type numeric in R. C++ example: /***evaluate_log_prior***/ double prior_eval(const Parameters &amp;parameters) { return dnorm(parameters[&quot;θ&quot;][0]); } R example: /***evaluate_log_prior,dnorm(parameters$θ)***/ 3.1.2 simulate_prior The simulate_prior function type samples from the prior distribution. Input: (C++ only) The random number generator. – of type RandomNumberGenerator &amp; in a C++ function Output: The simulated value. – of class Parameters in a C++ function – an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an = sign in the function header. C++ example: /***simulate_prior***/ Parameters prior_sim(RandomNumberGenerator &amp;rng) { return Parameters(&quot;θ&quot;,rnorm(rng)); } R example: /***simulate_prior,θ=rnorm(1)***/ 3.1.3 evaluate_gradient_log_prior The evaluate_gradient_log_prior function type gives the differential of the log prior density of the parameters. Input: The variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable in an R function Input: The point at which the gradient of the log prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The gradient of the log prior density of the parameters. – of type arma::mat in a C++ function – of type matrix in R. C++ example: /***evaluate_gradient_log_prior***/ arma::mat prior_gradient_eval(const std::string &amp;variable, const Parameters &amp;parameters) { if (variable==&quot;θ&quot;) { arma::mat grad(1,1); grad(0,0) = -parameters[&quot;θ&quot;][0]; return grad; } else { Rcpp::stop(&quot;Unknown variable in prior gradient.&quot;); } } R example: /***evaluate_gradient_log_prior,if (variable==&quot;θ&quot;) {-parameters$θ} else {stop(&quot;Unknown variable in prior gradient.&quot;)}***/ 3.1.4 evaluate_second_gradient_log_prior The evaluate_gradient_log_prior function type gives the second differential of the log prior density of the parameters. Input: The first variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable1 in an R function Input: The second variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable2 in an R function Input: The point at which the gradient of the log prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The Hessian of the log prior density, evaluated at the given point. – of type arma::mat in a C++ function – of type matrix in R C++ example: /***evaluate_second_gradient_log_prior***/ arma::mat prior_gradient_eval(const std::string &amp;variable1, const std::string &amp;variable2, const Parameters &amp;parameters) { if ((variable1==&quot;θ&quot;) &amp;&amp; (variable2==&quot;θ&quot;)) { arma::mat grad(1,1); grad(0,0) = -1.0; return grad; } else { Rcpp::stop(&quot;Unknown variable in prior second gradient.&quot;); } } R example: /***evaluate_second_gradient_log_prior,if ((variable1==&quot;θ&quot;) &amp;&amp; (variable2==&quot;θ&quot;)) {-1} else {stop(&quot;Unknown variable in prior second gradient.&quot;)}***/ "],["ilike-prior.html", "3.2 Factor: ilike prior", " 3.2 Factor: ilike prior 3.2.1 prior (ilike functions) The prior function type allows the user to specify the prior through an ilike function (e.g. ilike::norm). For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted. Example of the use of one of these functions (ilike::norm) follows. /***prior,ilike::norm(θ,0,1)***/ The following sections detail the available ilike functions. 3.2.1.1 Normal prior ilike::norm Specifies a normal prior over the given variable, with the given parameters. Inputs: string: the variable for which the prior is specified numeric: the mean of the normal distribution numeric: the standard deviation of the normal distribution 3.2.1.2 Multivariate normal prior ilike::mvnorm Specifies a multivariate normal prior over the given variable, with the given parameters. Inputs: string: the variable for which the prior is specified numeric vector/matrix: the mean of the multivariate normal distribution matrix: the covariance of the multivariate normal distribution 3.2.1.3 Lognormal prior ilike::lnorm Specifies a lognormal prior over the given variable, with the given parameters. Inputs: string: the variable for which the prior is specified numeric: the mean of the log of the variable numeric: the standard deviation of the log of the variable 3.2.1.4 Multivariate lognormal prior ilike::mvlnorm Specifies a multivariate loggnormal prior over the given variable, with the given parameters. Inputs: string: the variable for which the prior is specified numeric vector/matrix: the mean of the log of the variable matrix: the covariance of the log of the variable 3.2.1.5 Gamma prior ilike::gamma Specifies a gamma prior over the given variable, with the given parameters. Inputs: string: the variable for which the prior is specified numeric: the shape of the gamma distribution numeric: the rate of the gamma distribution "],["factor-custom-likelihood.html", "3.3 Factor: custom likelihood", " 3.3 Factor: custom likelihood The functions in this section allow the specification of a user-defined likelihood. Only the functions required by the chosen inference algorithm need be specified. Usually we recommend specifying, rather than a likelihood, the data model. This will ensure that, when running importance sampling for example, the normalising constant estimate returned by that algorithm will be an estimate of the marginal likelihood. However, where the goal is simulating from or approximating the posterior distribution, specifying the model up to proportionality is sufficient. 3.3.1 evaluate_log_likelihood The evaluate_log_likelihood function type calculates the log likelihood of the parameters. Input: The point at which the log likelihood is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Input: The observed data for which the log likelihood is to be evaluated. – of type const Data &amp; in a C++ function – available as R list data in an R function Output: The log likelihood of the parameters using the observed data. – of type double in a C++ function – of type numeric in R. C++ example: /***evaluate_log_likelihood***/ double likelihood_eval(const Parameters &amp;parameters, const Data &amp;data) { double y = data[&quot;y&quot;]; return sum(dnorm(y,parameters[&quot;θ&quot;][0],1.0)); } R example: /***evaluate_log_likelihood,sum(dnorm(data$y,parameters$θ,1.0))***/ 3.3.2 evaluate_gradient_log_likelihood The evaluate_gradient_log_likelihood function type calculates the gradient of the log likelihood of the parameters. Input: The variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable in an R function Input: The point at which the gradient of the log likelihood is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Input: The observed data for which the gradient of the log likelihood is to be evaluated. – of type const Data &amp; in a C++ function – available as R list data in an R function Output: The gradient of the log likelihood of the parameters. – of type arma::mat in a C++ function – of type matrix in R. C++ example: /***evaluate_gradient_log_likelihood***/ arma::mat likelihood_gradient_eval(const std::string &amp;variable, const Parameters &amp;parameters, const Data &amp;data) { if (variable==&quot;θ&quot;) { arma::colvec y = data[&quot;y&quot;]; arma::mat grad(1,1); grad(0,0) = arma::sum((y-parameters[&quot;θ&quot;][0])/1.0); return grad; } else { Rcpp::stop(&quot;Unknown variable in likelihood gradient.&quot;); } } R example: /***evaluate_gradient_log_likelihood,if (variable==&quot;θ&quot;) {sum((data$y-parameters$θ)/1.0)} else {stop(&quot;Unknown variable in likelihood gradient.&quot;)}***/ 3.3.3 evaluate_second_gradient_log_likelihood The evaluate_gradient_log_prior function type gives the second differential of the log likelihood of the parameters. Input: The first variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable1 in an R function Input: The second variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable2 in an R function Input: The point at which the gradient of the log prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The Hessian of the log likelihood, evaluated at the given point. – of type arma::mat in a C++ function – of type matrix in R. C++ example: /***evaluate_second_gradient_log_likelihood***/ arma::mat likelihood_hessian_eval(const std::string &amp;variable1, const std::string &amp;variable2, const Parameters &amp;parameters, const Data &amp;data) { if (variable1==&quot;θ&quot; &amp;&amp; variable2==&quot;θ&quot;) { arma::mat hess(1,1); hess(0,0) = -data[&quot;y&quot;].size()/1.0; return hess; } else { Rcpp::stop(&quot;Unknown variable in likelihood hessian.&quot;); } } R example: /***evaluate_second_gradient_log_likelihood,if (variable1==&quot;θ&quot; &amp;&amp; variable2==&quot;θ&quot;) {-length(data$y)/1.0} else {stop(&quot;Unknown variable in likelihood hessian.&quot;)}***/ "],["factor-simulation-based-likelihood.html", "3.4 Factor: simulation-based likelihood", " 3.4 Factor: simulation-based likelihood The functions in this section allow the specification of a likelihood through a function that simulates a data generating process, for example through approximate Bayesian computation. There are three function types that are required to be specified for all simulation-based likelihoods: simulate_data_model, which simulates the data generating process. data_variable, which specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. sbi_likelihood, which uses an ilike function to define the desired simulation-based likelihood. It is also possible to reduce the observed data to summary statistcs (though the use of the summary_statistics function type) for use in the simulation-based likelihood. 3.4.1 simulate_data_model The simulate_data_model function type simulates the data generating process. Input: (C++ only) The random number generator to be used in the simulation. – of type RandomNumberGenerator &amp; in a C++ function Input: The parameters at which to simulate the data. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The simulated data. – of class Data in a C++ function – an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an = sign in the function header. C++ example: /***simulate_data_model***/ Data simulate_data_model(RandomNumberGenerator &amp;rng, const Parameters &amp;parameters) { arma::colvec y = rnorm(rng,100,parameters[&quot;θ&quot;][0],1.0); return Data(&quot;y&quot;, y); } R example: /***simulate_data_model,y=rnorm(100,parameters$θ,1)***/ 3.4.2 data_variable The data_variable function type specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. There are no input arguments. Output: The variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. To specify multiple output variables they must be separated by a semi-colon (with no spaces). – of type const std::string &amp; in a C++ function – a string in R. C++ example: /***data_variable***/ std::string a_variable() { return &quot;y&quot;; // could be &quot;y;z&quot; for variables y and z } R example: /***data_variable,&quot;y&quot;***/ 3.4.3 summary_statistics The summary_statistics function type reduces the observed data to summary statistics for use in the simulation-based likelihood. The inclusion of this function type is optional: if it is included, then inference using the simulation-based likelihood will be conditional only on the summary statistics of the data, rather than the full data. If the argument is omitted, the simulation-based likelihood will use the full data. Input: Simulated/observed data. – of type const Data &amp; in a C++ function – available as R list data in an R function Output: The summary statistics of the data. – of type const Data &amp; in a C++ function – available as R list data in an R function C++ example: /***summary_statistics***/ Data summary_statistics(const Data &amp;data) { arma::colvec y = data[&quot;y&quot;]; return Data(&quot;y_mean&quot;, arma::mean(y)); } R example: /***summary_statistics,y_mean=mean(data$y)***/ 3.4.4 sbi_likelihood (ilike functions) The sbi_likelihood function type uses an ilike function to define the desired simulation-based likelihood. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted. Example of the use of one of these functions (ilike::sl) follows. /***sbi_likelihood,ilike::sl(50)***/ All of these methods use simulations from the data generating process (DGP) to construct an approximate likelihood from data \\(y_{\\mbox{obs}}\\). \\(s_{\\mbox{obs}}\\) is used to denote the result of applying the summary_statistic function to \\(y_{\\mbox{obs}}\\). Let \\(y^{1:M}\\) be \\(M\\) draws from the DGP \\(f(\\cdot \\mid \\theta)\\) for parameter \\(\\theta\\) and let \\(s^{1:M}\\) be the result of applying the summary_statistic function to each corresponding simulation. Suppose that each summary statistic lies in \\(\\mathbb{R}^{d_s}\\): this vector is the result of stacking the summary statistics named in the data_variable function type. The available ilike functions are detailed in the following sections. 3.4.4.1 Synthetic likelihood ilike::sl Specifies a synthetic likelihood (SL), as described in Wood (2010) and Price et al. (2018). The synthetic likelihood \\(l(s_{\\mbox{obs}} \\mid \\theta)\\) is given by \\[ l(s_{\\mbox{obs}} \\mid \\theta) = \\mathcal{MVN}\\left( s_{\\mbox{obs}} \\mid \\hat{\\mu}, \\hat{\\Sigma} \\right), \\tag{3.1} \\] where \\[ \\hat{\\mu} = \\frac{1}{M} \\sum_{j=1}^M s^{j} \\qquad \\hat{\\Sigma} = \\frac{1}{M-1} \\sum_{j=1}^M \\left( s^{j} - \\hat{\\mu} \\right) \\left( s^{j} - \\hat{\\mu} \\right)^T. \\tag{3.2} \\] Price et al. (2018) describes an extended version of this approach, which uses an unbiased estimate of the Gaussian distribution in equation (3.1), also based on \\(\\hat{\\mu}\\) and \\(\\hat{\\Sigma}\\) from equation (3.2). Inputs: integer: the number of simulations \\(M\\) to use in the synthetic likelihood (optional) boolean: whether to use the unbiased version of synthetic likelihood described in Price et al. (2018) (default is false) (optional) boolean: whether to store the output of the model simulations (default is false) (optional) boolean: whether to run the simulations in parallel (default is false) (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) 3.4.4.2 ABC (uniform kernel; Euclidean distance) ilike::euclidean_uniform_abc Specifies an approximate Bayesian computation (ABC), using a uniform kernel and Euclidean distance metric, as described in Sisson, Fan, and Beaumont (2018). The euclidean_uniform_abc likelihood \\(l(s_{\\mbox{obs}} \\mid \\theta)\\) is given, for tolerance level \\(\\epsilon\\), by \\[ l(s_{\\mbox{obs}} \\mid \\theta) = \\frac{1}{M}\\sum_{j=1}^{M}K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) \\] where \\[ K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) = \\begin{cases} 1/c &amp; \\text{if } d( s_{\\mbox{obs}} - s^{j} ) \\leq \\epsilon \\\\ 0 &amp; \\text{otherwise} \\end{cases}, \\] for \\[ c = \\frac{2^{d_s}\\Gamma\\left(\\frac{1}{2}+1\\right)^{d_s}}{\\Gamma\\left(\\frac{d_s}{2}+1\\right)}\\epsilon^{d_s}\\sum_{i=1}^{d_s}\\sigma_{i} \\] where \\[ d(s_{\\text{obs}},s)=\\left(\\sum_{i=1}^{d_{s}}\\left(\\frac{s_{\\text{obs},i}-s_{i}}{\\sigma_{i}}\\right)^{2}\\right)^{1/2} \\] Here \\(\\sigma_i\\) is a scaling used for the \\(i\\)th dimension of \\(s\\). The value of \\(c\\) is here to ensure that the uniform kernel is normalised, and uses the formula for volume of a \\(d_s\\)-dimensional ball. Inputs: integer: the number of simulations \\(M\\) to use in the ABC string: the name of the tolerance variable in the ABC numeric: the tolerance level for the ABC (optional) string: the name of the variable that stores the scaling \\(\\sigma_i\\) of the data/summaries in the ABC (default is \"\" - in this case the scale will be 1 for every dimension) (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 4) is set. (optional) boolean: whether to store the output of the model simulations (default is false) (optional) boolean: whether to run the simulations in parallel (default is false) (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) 3.4.4.3 ABC (uniform kernel; \\(L^p\\) distance) ilike::lp_uniform_abc Specified an approximate Bayesian computation (ABC) likelihood, using a uniform kernel and the \\(L^p\\) distance metric. The lp_uniform_abc likelihood \\(l(y \\mid \\theta)\\) is given, for tolerance level \\(\\epsilon\\), by \\[ l(s_{\\mbox{obs}} \\mid \\theta) = \\frac{1}{M}\\sum_{j=1}^{M}K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) \\] where \\[ K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) = \\begin{cases} 1/c &amp; \\text{if } d( s_{\\mbox{obs}} - s^{j} ) \\leq \\epsilon \\\\ 0 &amp; \\text{otherwise} \\end{cases}, \\] for \\[ c = \\frac{2^{d_s}\\Gamma\\left(\\frac{1}{p}+1\\right)^{d_s}}{\\Gamma\\left(\\frac{d_s}{p}+1\\right)}\\epsilon^{d_s}\\sum_{j=1}^{d_s}\\sigma_{i} \\] where \\[ d(s_{\\text{obs}},s)=\\left(\\sum_{i=1}^{d_{s}}\\left(\\frac{s_{\\text{obs},i}-s_{i}}{\\sigma_{i}}\\right)^{p}\\right)^{1/p} \\] Here \\(\\sigma_i\\) is a scaling used for the \\(i\\)th dimension of \\(s\\). The value of \\(c\\) is here to ensure that the uniform kernel is normalised, and uses the formula for volume of a \\(d_s\\)-dimensional ball in \\(L^p\\) space. Inputs: integer: the number of simulations \\(M\\) to use in the ABC string: the name of the tolerance variable in the ABC numeric: the tolerance level for the ABC numeric: the value of \\(p\\) for the \\(L^p\\) distance metric (optional) string: the name of the variable that stores the scaling \\(\\sigma_i\\) of the data/summaries in the ABC (default is \"\" - in this case the scale will be 1 for every dimension) (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 5) is set. (optional) boolean: whether to store the output of the model simulations (default is false) (optional) boolean: whether to run the simulations in parallel (default is false) (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) 3.4.4.4 ABC (Gaussian kernel) ilike::gaussian_abc Specifies an approximate Bayesian computation (ABC) likelihood, using a Gaussian kernel. The gaussian_abc likelihood \\(l(s_{\\mbox{obs}} \\mid \\theta)\\) is given, for tolerance level \\(\\epsilon\\), by \\[ l(s_{\\mbox{obs}} \\mid \\theta) = \\frac{1}{M}\\sum_{j=1}^{M}K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) \\] where \\[ K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) = \\left(2\\pi\\epsilon\\right)^{-d_{y}/2}\\prod_{i=1}^{d_{s}}\\frac{1}{\\sigma_{i}^{2}}\\exp\\left(-\\frac{1}{2\\epsilon^{2}}\\sum_{i=1}^{d_{s}}\\left(\\frac{s_{\\text{obs},i}-s_{i}}{\\sigma_{i}}\\right)^{2}\\right). \\] Here \\(\\sigma_i\\) is a scaling used for the \\(i\\)th dimension of \\(s\\). Inputs: integer: the number of simulations \\(M\\) to use in the ABC string: the name of the tolerance variable in the ABC numeric: the tolerance level for the ABC (optional) string: the name of the variable that stores the scaling \\(\\sigma_i\\) of the data/summaries in the ABC (default is \"\" - in this case the scale will be 1 for every dimension) (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 4) is set. (optional) boolean: whether to store the output of the model simulations (default is false) (optional) boolean: whether to run the simulations in parallel (default is false) (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) 3.4.4.5 IEnKI-ABC ilike::ienki_abc Specifies an approximate Bayesian computation (ABC) likelihood, estimating using iterative ensemble Kalman inversion (IEnKI), as described in Everitt (2024). This approach uses an alternative estimator for the ABC likelihood using the Gaussian kernel, with tolerance \\(\\epsilon\\), described in section 3.4.4.4. IEnKI uses an ensemble of points to simulate from a sequence of \\(0:T\\) distributions using a decreasing sequence of tolerances \\(\\infty = \\epsilon_0 &gt; .... &gt; \\epsilon_T = \\epsilon\\). The 0th distrbution is \\(f_s( s \\mid \\theta)\\) (corresponding to the case where \\(\\epsilon=\\infty\\)), where \\(f_s\\) is the distribution resulting from the data generating process \\(f( \\cdot \\mid \\theta)\\) and the summary statistic transformation. The \\(t\\)th distribution for \\(t&gt;0\\) is \\(f_s( s \\mid \\theta) K_{\\epsilon_t}\\left(s_{\\text{obs}}\\mid s\\right)\\). The estimator of the normalising constant of the final target distribution, constructed using the ensemble at each step of the IEnKI, is an estimator of the ABC likelihood. This estimator is biased in general, but is likely to have significantly lower variance than that from standard ABC. When the final \\(\\epsilon\\) is taken to be zero, and \\(T=1\\), the estimator is the same as that used in synthetic likelihood (section 3.4.4.1). Full details can be found in Everitt (2024). Inputs: integer: the number of ensemble members \\(M\\) to use in the IEnKI-ABC integer: the estimator type constructed from the IEnKI output. The meaning of each of the four options below is given in the paper Everitt (2024). The options are: 1 (recommended): the “direct” estimator 2: the “unbiased” estimator, using the approach analogous to the unbiased method in Price et al. (2018) 3: the path sampling estimator 4: the alternative path sampling estimator from Friel, Hurn, and Wyse (2014) string: the name of the tolerance variable in the ABC numeric: the tolerance level for the ABC string: the shifter used in the IEnKI (the method for moving the ensemble at each iteration). The options are: stochastic (recommended): the stochastic shifter sqrt: the square root shifter adjustment: the adjustment shifter integer: the number of targets \\(T\\) used in the IEnKI (optional) numeric: the significance level for the significance test used in determining when to use the target skipping approach proposed in Everitt (2024) (default is 1, which results in skipping no targets; 0.1 recommended when using the stochastic shifter) (optional) integer: the number of iterations of output of each run of the IEnKI to store, counting from the final iteration backwards (default is 0) (optional) string: the name of the variable that stores the scaling \\(\\sigma_i\\) of the data/summaries in the ABC (default is \"\" - in this case the scale will be 1 for every dimension) (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 5) is set. (optional) boolean: whether to perform the IEnKI on the summary statistic space (default is true; false is largely untested) (optional) boolean: whether to run the simulations in parallel (default is false) (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) References Everitt, Richard G. 2024. “Ensemble Kalman Inversion Approximate Bayesian Computation.” arXiv Preprint arXiv:2407.18721. Friel, Nial, Merrilee Hurn, and Jason Wyse. 2014. “Improving Power Posterior Estimation of Statistical Evidence.” Statistics and Computing 24: 709–23. Price, Leah F, Christopher C Drovandi, Anthony Lee, and David J Nott. 2018. “Bayesian Synthetic Likelihood.” Journal of Computational and Graphical Statistics 27 (1): 1–11. Sisson, Scott A, Yanan Fan, and Mark Beaumont. 2018. Handbook of Approximate Bayesian Computation. CRC press. Wood, Simon N. 2010. “Statistical Inference for Noisy Nonlinear Ecological Dynamic Systems.” Nature 466 (7310): 1102–4. "],["factor-linear-gaussian-model.html", "3.5 Factor: linear-Gaussian model", " 3.5 Factor: linear-Gaussian model A commonly-used class of model is one where data \\(y\\) arises from a linear function of some latent state, plus some Gaussian noise, i.e. \\[ y \\sim \\mathcal{MVN}(H x, R) \\tag{3.3} \\] where \\(H\\) is a matrix and \\(R\\) is a covariance matrix. The linear-Gaussian data model subtype allows the specification of such model, through providing the variable names (\\(y\\) and \\(x\\) here) and the values for \\(H\\) and \\(R\\). Note that, using this block subtype, it would be possible to specify a model for a number of independent observations from a Gaussian distribution. However, this would be an inefficient way of specifying this model since it would require the user to supply a large diagonal covariance matrix. Such a model would be more effectively specified via the exact_likelihood block sutype. There are two ways of specifying a linear-Gaussian data model: Through the function types linear_gaussian_data_variable (specifying the name of the \\(y\\) variable), linear_gaussian_data_state_variable (specifying the name of the \\(x\\) variable), linear_gaussian_data_matrix (specifying the \\(A\\) matrix), and linear_gaussian_data_covariance (specifying the name of the \\(\\Sigma\\) matrix), The user needs to provide all of these functions in order to fully specify the model. Through the function type linear_gaussian_data_model, which allows the user to specify the complete model through an ilike function. We now detail the function types. 3.5.1 linear_gaussian_data_variable Specifies the name of the observed data variable in the linear-Gaussian data model. There are no input arguments. Output: The name of the variable used as \\(y\\) in equation (3.3). – of type const std::string &amp; in a C++ function – a string in R. C++ example: /***linear_gaussian_data_variable***/ std::string set_data_variable() { return &quot;y&quot;; } R example: /***linear_gaussian_data_variable,&quot;y&quot;***/ 3.5.2 linear_gaussian_data_state_variable Specifies the name of the latent state variable in the linear-Gaussian data model. There are no input arguments. Output: The name of the variable used as \\(x\\) in equation (3.3). – of type const std::string &amp; in a C++ function – a string in R. C++ example: /***linear_gaussian_data_state_variable***/ std::string set_state_variable() { return &quot;x&quot;; } R example: /***linear_gaussian_data_state_variable,&quot;x&quot;***/ 3.5.3 linear_gaussian_data_matrix Specifies the matrix \\(A\\) in the linear-Gaussian data model. Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The matrix \\(A\\) in equation (3.3). – of type arma::mat in a C++ function – a matrix in R. C++ examples: /***linear_gaussian_data_matrix***/ arma::mat set_matrix() { arma::mat A(2,2); A(0,0) = 1.0; A(0,1) = 0.0; A(1,0) = 0.0; A(1,1) = 1.0; return A; } or /***linear_gaussian_data_matrix***/ arma::mat set_matrix(const Parameters &amp;parameters) { double scale = parameters[&quot;scale&quot;][0]; arma::mat A(2,2); A(0,0) = scale; A(0,1) = 0.0; A(1,0) = 0.0; A(1,1) = scale; return A; } R example: /***linear_gaussian_data_matrix,diag(2)***/ or /***linear_gaussian_data_matrix,parameters$scale*diag(2)***/ 3.5.4 linear_gaussian_data_covariance Specifies the covariance matrix \\(R\\) in the linear-Gaussian data model. Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The covariance matrix \\(R\\) in equation (3.3). – of type arma::mat in a C++ function – a matrix in R C++ examples: /***linear_gaussian_data_covariance***/ arma::mat set_covariance() { arma::mat R(2,2); R(0,0) = 1.0; R(0,1) = 0.0; R(1,0) = 0.0; R(1,1) = 1.0; return R; } or /***linear_gaussian_data_covariance***/ arma::mat set_covariance(const Parameters &amp;parameters) { double scale = parameters[&quot;scale&quot;][0]; arma::mat R(2,2); R(0,0) = scale; R(0,1) = 0.0; R(1,0) = 0.0; R(1,1) = scale; return R; } R examples: /***linear_gaussian_data_covariance,diag(2)***/ or /***linear_gaussian_data_covariance,parameters$scale*diag(2)***/ 3.5.5 linear_gaussian_data_model (ilike function) We may use an ilike function to specify the complete linear-Gaussian data model. 3.5.5.1 Linear-Gaussian data model ilike::linear_gaussian_data_model Specifies the linear-Gaussian data model. Inputs: string: The name of the observed data variable string: The name of the latent state variable matrix: The matrix \\(A\\) matrix: The covariance matrix \\(R\\) "],["factor-nonlinear-gaussian-model.html", "3.6 Factor: nonlinear-Gaussian model", " 3.6 Factor: nonlinear-Gaussian model The nonlinear-Gaussian data model subtype may be used to specify a model where data \\(y\\) arises from a nonlinear function of some latent state, plus some Gaussian noise, i.e. \\[ y \\sim \\mathcal{N}(g(x), R) \\tag{3.4} \\] where \\(g\\) is a function and \\(R\\) is a covariance matrix. To specify the model we need to provide the variable name (\\(y\\)), the function \\(g\\) and the matrix \\(R\\). To do this the user must provide three function types, respectively: nonlinear_gaussian_data_variable, nonlinear_gaussian_data_function and nonlinear_gaussian_data_covariance. 3.6.1 nonlinear_gaussian_data_variable Specifies the name of the observed data variable. There are no input arguments. Output: The name of the observed data variable. – of type const std::string &amp; in a C++ function – a string in R. C++ example: /***nonlinear_gaussian_data_variable***/ std::string set_variable() { return &quot;y&quot;; } R example: /***nonlinear_gaussian_data_variable,&quot;y&quot;***/ 3.6.2 nonlinear_gaussian_data_function Specifies the function \\(g\\) in the nonlinear-Gaussian data model. Input: The state \\(x\\) and any parameters that the function relies on (the latter may be included to allow the specification of a parameter-dependent function) – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The output of the function \\(g\\) in equation (3.4). – of type const Data &amp; in a C++ function – a list in R. C++ example: /***nonlinear_gaussian_data_function***/ Data transform_into_data_space(const Parameters &amp;x_and_theta) { arma::colvec noiseless_y(1,1); noiseless_y[0] = exp(x_and_theta[&quot;x&quot;][0) + x_and_theta[&quot;theta&quot;][0]; return Data(&quot;y&quot;, noiseless_y); } R example: /***nonlinear_gaussian_data_function,y=exp(parameters$x)+parameters$theta***/ 3.6.3 nonlinear_gaussian_data_covariance Specifies the covariance matrix \\(R\\) in the nonlinear-Gaussian data model. Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The covariance matrix \\(R\\) in equation (3.4). – of type arma::mat in a C++ function – a matrix in R. C++ examples: /***nonlinear_gaussian_data_covariance***/ arma::mat set_covariance() { arma::mat R(2,2); R(0,0) = 1.0; R(0,1) = 0.0; R(1,0) = 0.0; R(1,1) = 1.0; return R; } or /***nonlinear_gaussian_data_covariance***/ arma::mat set_covariance(const Parameters &amp;parameters) { double scale = parameters[&quot;scale&quot;][0]; arma::mat R(2,2); R(0,0) = scale; R(0,1) = 0.0; R(1,0) = 0.0; R(1,1) = scale; return R; } R examples: /***nonlinear_gaussian_data_covariance,diag(2)***/ or /***nonlinear_gaussian_data_covariance,parameters$scale*diag(2)***/ "],["factor-algorithmic-likelihood.html", "3.7 Factor: algorithmic likelihood", " 3.7 Factor: algorithmic likelihood For some models, the likelihood can be computed or estimated by running an algorithm. For example, the marginal likelihood of a state-space model may be estimated using a particle filter. To specify such a likelihood, the user must provide a function type likelihood, then use an ilike function to specify the type of likelihood. 3.7.1 likelihood (ilike functions) The likelihood function type allows the user to specify the likelihood through an ilike function. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted. The available ilike functions are detailed in the following sections. 3.7.1.1 Kalman filter ilike::kf The Kalman filter (KF) is a recursive algorithm that estimates the state of a linear Gaussian state-space model and, in this context, can be used to calculate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running a KF from the ilike R package as described in section 4.7. Inputs: string: The name of an ilike file (with extension) that contains the specification of a linear-Gaussian state-space model and the required ilike function for setting up a filter, as described in section 3.11.1. A full description of what is required in the file is given in section 4.7. (optional) integer: THe number of iterations output of the KF to store, counting from the final iteration backwards (default is 0) 3.7.1.2 Particle filter ilike::pf The particle filter is a recursive algorithm that estimates the state of a general state-space model and, in this context, can be used to estimate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running a PF from the ilike R package as described in section 4.8. Inputs: string: The name of an ilike file (with extension) that contains the specification of a general state-space model and the required ilike function for setting up a filter, as described in section 3.11.1. A full description of what is required in the file is given in section 4.8. integer: The number of particles to use in the particle filter. (optional) integer: The number of iterations output of the PF to store, counting from the final iteration backwards (default is 0). (optional) boolean: Whether to run the particle filter in parallel (default is false). (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) 3.7.1.3 Ensemble Kalman filter ilike::enkf The ensemble Kalman filter (EnKF) is a recursive algorithm that estimates the state of a general state-space model and, in this context, can be used to estimate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running an EnKF from the ilike R package as described in section 4.9. Inputs: string: The name of an ilike file (with extension) that contains the specification of a general state-space model and the required ilike function for setting up a filter, as described in section 3.11.1. A full description of what is required in the file is given in section 4.9. integer: The number of ensemble members to use in the EnKF. string: The name of the shifter to use in the EnKF (the method for moving the ensemble at each iteration). The options are: stochastic: the stochastic shifter sqrt: the square root shifter adjustment: the adjustment shifter (optional) integer: The number of iterations output of the EnKF to store, counting from the final iteration backwards (default is 0). (optional) boolean: Whether to run the EnKF in parallel (default is false). (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) "],["transition-model-linear-gaussian.html", "3.8 Transition model: linear-Gaussian", " 3.8 Transition model: linear-Gaussian The linear-Gaussian transition model subtype may be used to specify a transition model in a state-space model that consists of a linear function of the state, plus some Gaussian noise, i.e. \\[ x_t \\sim \\mathcal{N}(A x_{t-1}, Q) \\tag{3.5} \\] where \\(A\\) is a matrix and \\(Q\\) is a covariance matrix. To specify the model we need to provide the state name (\\(x\\)), the matrix \\(A\\) and the matrix \\(Q\\). There are two ways of specifying a linear-Gaussian data model: Through the function types linear_gaussian_transition_variable (specifying the name of the \\(x\\) variable), linear_gaussian_transition_matrix (specifying the \\(A\\) matrix), and linear_gaussian_transition_covariance (specifying the name of the \\(Q\\) matrix), The user needs to provide all of these functions in order to fully specify the model. Through the function type linear_gaussian_transition_model, which allows the user to specify the complete model through an ilike function. We now detail the function types. 3.8.1 linear_gaussian_transition_variable Specifies the name of the observed transition variable in the linear-Gaussian transition model. There are no input arguments. Output: The name of the variable used as \\(x\\) in equation (3.5). – of type const std::string &amp; in a C++ function – a string in R. C++ example: /***linear_gaussian_transition_variable***/ std::string set_transition_variable() { return &quot;x&quot;; } R example: /***linear_gaussian_transition_variable,&quot;x&quot;***/ 3.8.2 linear_gaussian_transition_matrix Specifies the matrix \\(A\\) in the linear-Gaussian transition model. Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The matrix \\(A\\) in equation (3.5). – of type arma::mat in a C++ function – a matrix in R. C++ examples: /***linear_gaussian_transition_matrix***/ arma::mat set_matrix() { arma::mat A(2,2); A(0,0) = 1.0; A(0,1) = 0.0; A(1,0) = 0.0; A(1,1) = 1.0; return A; } or /***linear_gaussian_transition_matrix***/ arma::mat set_matrix(const Parameters &amp;parameters) { double scale = parameters[&quot;scale&quot;][0]; arma::mat A(2,2); A(0,0) = scale; A(0,1) = 0.0; A(1,0) = 0.0; A(1,1) = scale; return A; } R example: /***linear_gaussian_transition_matrix,diag(2)***/ or /***linear_gaussian_transition_matrix,parameters$scale*diag(2)***/ 3.8.3 linear_gaussian_transition_covariance Specifies the covariance matrix \\(Q\\) in the linear-Gaussian transition model. Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The covariance matrix \\(Q\\) in equation (3.5). – of type arma::mat in a C++ function – a matrix in R C++ examples: /***linear_gaussian_transition_covariance***/ arma::mat set_covariance() { arma::mat Q(2,2); Q(0,0) = 1.0; Q(0,1) = 0.0; Q(1,0) = 0.0; Q(1,1) = 1.0; return Q; } or /***linear_gaussian_transition_covariance***/ arma::mat set_covariance(const Parameters &amp;parameters) { double scale = parameters[&quot;scale&quot;][0]; arma::mat Q(2,2); Q(0,0) = scale; Q(0,1) = 0.0; Q(1,0) = 0.0; Q(1,1) = scale; return Q; } R examples: /***linear_gaussian_transition_covariance,diag(2)***/ or /***linear_gaussian_transition_covariance,parameters$scale*diag(2)***/ 3.8.4 linear_gaussian_transition_model (ilike function) We may use an ilike function to specify the complete linear-Gaussian transition model. 3.8.4.1 Linear-Gaussian transition model ilike::linear_gaussian_transition_model Specifies the linear-Gaussian transition model. Inputs: string: The name of the observed transition variable string: The name of the latent state variable matrix: The matrix \\(A\\) matrix: The covariance matrix \\(Q\\) "],["transition-model-nonlinear-gaussian.html", "3.9 Transition model: nonlinear-Gaussian", " 3.9 Transition model: nonlinear-Gaussian The nonlinear-Gaussian transition model subtype may be used to specify a model where the state \\(x_t\\) has a Gaussian distribution where the mean depends nonlinearly on \\(x_{t-1}\\), plus some Gaussian noise, i.e. \\[ x_t \\sim \\mathcal{N}(g(x_{t-1}), Q) \\tag{3.6} \\] where \\(g\\) is a function and \\(Q\\) is a covariance matrix. To specify the model we need to provide the variable name (\\(x\\)), the function \\(g\\) and the matrix \\(Q\\). To do this the user must provide three function types, respectively: nonlinear_gaussian_transition_variable, nonlinear_gaussian_transition_function and nonlinear_gaussian_transition_covariance. 3.9.1 nonlinear_gaussian_transition_variable Specifies the name of the observed transition variable. There are no input arguments. Output: The name of the observed transition variable. – of type const std::string &amp; in a C++ function – a string in R. C++ example: /***nonlinear_gaussian_transition_variable***/ std::string set_variable() { return &quot;x&quot;; } R example: /***nonlinear_gaussian_transition_variable,&quot;x&quot;***/ 3.9.2 nonlinear_gaussian_transition_function Specifies the function \\(g\\) in the nonlinear-Gaussian transition model. Input: The state \\(x\\) and any parameters that the function relies on (the latter may be included to allow the specification of a parameter-dependent function) – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The output of the function \\(g\\) in equation (3.6). – of type const Parameters &amp; in a C++ function – a list in R. C++ example: /***nonlinear_gaussian_transition_function***/ Parameters transform_state(const Parameters &amp;xtminus1_and_theta) { arma::colvec noiseless_xt(1,1); noiseless_xt[0] = exp(xtminus1_and_theta[&quot;x&quot;][0) + xtminus1_and_theta[&quot;theta&quot;][0]; return Parameters(&quot;x&quot;, noiseless_xt); } R example: /***nonlinear_gaussian_transition_function,x=exp(parameters$x)+parameters$theta***/ 3.9.3 nonlinear_gaussian_transition_covariance Specifies the covariance matrix \\(Q\\) in the nonlinear-Gaussian transition model. Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The covariance matrix \\(Q\\) in equation (3.6). – of type arma::mat in a C++ function – a matrix in R. C++ examples: /***nonlinear_gaussian_transition_covariance***/ arma::mat set_covariance() { arma::mat Q(2,2); Q(0,0) = 1.0; Q(0,1) = 0.0; Q(1,0) = 0.0; Q(1,1) = 1.0; return Q; } or /***nonlinear_gaussian_transition_covariance***/ arma::mat set_covariance(const Parameters &amp;parameters) { double scale = parameters[&quot;scale&quot;][0]; arma::mat Q(2,2); Q,0) = scale; Q(0,1) = 0.0; Q(1,0) = 0.0; Q(1,1) = scale; return Q; } R examples: /***nonlinear_gaussian_transition_covariance,diag(2)***/ or /***nonlinear_gaussian_transition_covariance,parameters$scale*diag(2)***/ "],["transition-model-custom.html", "3.10 Transition model: custom", " 3.10 Transition model: custom The functions in this section allow the specification of a user-defined transition model. Only the functions required by the chosen inference algorithm need be specified. 3.10.1 simulate_transition model The simulate_transition_model function type simulates the latent state at time \\(t\\) given the latent state at time \\(t-1\\) and any parameters that the model relies on. Input: (C++ only) The random number generator. – of type RandomNumberGenerator &amp; in a C++ function Input: The latent state at time \\(t-1\\) and any parameters that the model relies on. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The latent state at time \\(t\\). – of type const Parameters &amp; in a C++ function – a list in R. C++ example: /***simulate_transition_model***/ Parameters simulate_state(RandomNumberGenerator &amp;rng, const Parameters &amp;xtminus1_and_theta) { arma::colvec xt(1,1); noiseless_xt[0] = exp(xtminus1_and_theta[&quot;x&quot;][0) + xtminus1_and_theta[&quot;theta&quot;][0] + rng.normal(0.0, 1.0); return Parameters(&quot;x&quot;, noiseless_xt); } ### evaluate_log_transition_model ## Data block ### data The `data` function type returns observed data. There are no input arguments. Output: The observed data. -- of class `Data` in a C++ function -- an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an `=` sign in the function header. C++ example: /***data***/ Data set_data() { arma::colvec y(2,1); y[0] = 1.0; y[1] = 2.0; return Data(&quot;y&quot;, y); } R example: /***evaluate_log_prior,y=c(1,2)***/ "],["method-block.html", "3.11 Method block", " 3.11 Method block 3.11.1 filter 3.11.1.1 Filtering instructions ilike::filter // Arguments are: // name of index variable // first index // final index // name of time variable // initial time // time step variable // time step size // predictions per update /filter,ilike::filter(i,0,15,t,0,dt,2,1)/ prior_function_types = c(&quot;prior&quot;,&quot;evaluate_log_prior&quot;,&quot;simulate_prior&quot;,&quot;evaluate_gradient_log_prior&quot;,&quot;evaluate_second_gradient_log_prior&quot;) custom_likelihood_function_types = c(&quot;evaluate_log_likelihood&quot;,&quot;evaluate_gradient_log_likelihood&quot;,&quot;evaluate_second_gradient_log_likelihood&quot;) #file_likelihood_types = c(&quot;importance_sample&quot;,&quot;smc_mcmc_move&quot;) sbi_likelihood_function_types = c(&quot;simulate_data_model&quot;,&quot;sbi_likelihood&quot;,&quot;summary_statistics&quot;,&quot;data_variable&quot;) linear_gaussian_data_model_types = c(&quot;linear_gaussian_data_model&quot;,&quot;linear_gaussian_data_matrix&quot;,&quot;linear_gaussian_data_covariance&quot;,&quot;linear_gaussian_data_variable&quot;,&quot;linear_gaussian_data_state_variable&quot;) nonlinear_gaussian_data_model_types = c(&quot;nonlinear_gaussian_data_model&quot;,&quot;nonlinear_gaussian_data_function&quot;,&quot;nonlinear_gaussian_data_covariance&quot;,&quot;nonlinear_gaussian_data_variable&quot;) other_likelihood_function_types = c(&quot;likelihood&quot;) factor_function_types = c(prior_function_types,custom_likelihood_function_types,sbi_likelihood_function_types,linear_gaussian_data_model_types,nonlinear_gaussian_data_model_types,other_likelihood_function_types) ilike_transition_model_types = c(&quot;transition_model&quot;) linear_gaussian_transition_model_types = c(&quot;linear_gaussian_transition_model&quot;,&quot;linear_gaussian_transition_matrix&quot;,&quot;linear_gaussian_transition_covariance&quot;,&quot;linear_gaussian_transition_variable&quot;) nonlinear_gaussian_transition_model_types = c(&quot;nonlinear_gaussian_transition_model&quot;,&quot;nonlinear_gaussian_transition_function&quot;,&quot;nonlinear_gaussian_transition_covariance&quot;,&quot;nonlinear_gaussian_transition_variable&quot;) custom_transition_model_types = c(&quot;simulate_transition_model&quot;,&quot;evaluate_log_transition_model&quot;) transition_model_types = c(ilike_transition_model_types,linear_gaussian_transition_model_types,nonlinear_gaussian_transition_model_types,custom_transition_model_types) custom_potential_function_types = c(&quot;evaluate_log_potential_function&quot;) ilike_potential_function_types = c(&quot;potential_function&quot;) potential_function_types = c(custom_potential_function_types,ilike_potential_function_types) data_function_types = c(&quot;data&quot;) importance_proposal_types = c(&quot;simulate_importance_proposal&quot;,&quot;evaluate_log_importance_proposal&quot;,&quot;importance_proposal&quot;) mh_proposal_types = c(&quot;simulate_mh_proposal&quot;,&quot;evaluate_log_mh_proposal&quot;,&quot;mh_proposal&quot;,&quot;mh_transform&quot;,&quot;mh_inverse_transform&quot;,&quot;mh_transform_jacobian_matrix&quot;,&quot;mh_factor_index&quot;) unadjusted_proposal_types = c(&quot;simulate_unadjusted_proposal&quot;,&quot;unadjusted_proposal&quot;,&quot;unadjusted_transform&quot;,&quot;unadjusted_inverse_transform&quot;,&quot;unadjusted_transform_jacobian_matrix&quot;,&quot;unadjusted_factor_index&quot;) independent_mh_proposal_types = c(&quot;simulate_independent_mh_proposal&quot;,&quot;evaluate_log_independent_mh_proposal&quot;,&quot;independent_mh_proposal&quot;,&quot;independent_mh_transform&quot;,&quot;independent_mh_inverse_transform&quot;,&quot;independent_mh_transform_jacobian_matrix&quot;,&quot;independent_mh_factor_index&quot;) m_proposal_types = c(&quot;simulate_m_proposal&quot;,&quot;m_proposal&quot;,&quot;m_transform&quot;,&quot;m_inverse_transform&quot;,&quot;m_transform_jacobian_matrix&quot;,&quot;m_factor_index&quot;) transition_proposal_types = c(&quot;simulate_transition_proposal&quot;,&quot;evaluate_log_transition_proposal&quot;) enk_transform_types = c(&quot;enk_transform&quot;,&quot;enk_inverse_transform&quot;) #reinforce_gradient = c(&quot;reinforce_gradient&quot;) method_function_types = c(&quot;mcmc_weights&quot;,&quot;mcmc_termination&quot;,&quot;adaptive_resampling&quot;,&quot;adaptive_target&quot;,&quot;smc_termination&quot;,&quot;smc_sequence&quot;,&quot;reinforce_gradient&quot;,&quot;enk_likelihood_index&quot;,&quot;enk_shifter&quot;,&quot;filter&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
