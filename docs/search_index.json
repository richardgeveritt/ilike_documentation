[["ilike-files.html", "Chapter 2 ilike files", " Chapter 2 ilike files The ilike package uses an ilike file is used to specify the statistical model (priors and likelihoods) on which we will perform inference, along with the data and functions and parameters for the inference algorithm. This section gives a full description of how to specify this file. An ilike file is an adapted version of a C++ source file: but don’t let this put you off if you don’t know C++! It is possible to specify an ilike file without knowing any C++ at all. The functions in an ilike file can be specified using C++, R, python, julia. A section will be devoted to specifying the file via each of these languages. Additionally, some functions in the file may be specified by using commands that are native to the ilike package, and different functions in the file may be specified using different languages. The ilike file is compiled before it is used for running inference algorithms. This section fully describes the structure of the file (section 2.1), how to compile an ilike file (section 2.2) and how to write functions in C++ (2.3), R (2.4), python (2.5), julia (2.6). ilike native functions are described in section 2.7. "],["file-structure.html", "2.1 File structure", " 2.1 File structure The ilike file must contain all of the functions required to run the desired algorithm. In most cases the following will be required: A function that returns observed data. This is not required when using the algorithms for simulation from a target distribution that is not conditioned on data. A complete specification of a joint distribution. Usually this will consist of one or more prior distributions and one or more likelihoods1. To use a target distribution that is not conditioned on data, no likelihoods need to be specified, and the target is given solely by the “prior”. Functions that are required to run the inference algorithm. For example, the proposal to use in a Metropolis-Hastings algorithm. An ilike file consists of “blocks” of content, each of which specifies a component of the model (or in some cases the the inference algorithm). In an example of a simple model, the prior may be specified in one block, the likelihood in another, and the data in another. A block may consist of more than one function. Each function in an ilike file must have a function type specified in a header in the line above the function. A header is enclosed in the characters \\*** at the beginning and ***\\ at the end, with the function type written directly after the beginning characters \\***. See, for example, in section , the function that specifies how to evaluate the log of a prior density that has the header /***evaluate_log_prior***/, which defines the function type to be evaluate_log_prior. For example, a block containing a prior may include two functions: evaluate_log_prior and simulate_prior. The functions included in a block depend on which algorithm we would like to run. Blocks may be specified explicitly or determined automatically: To explicitly end a block, include the characters //# on a new line in the file after a function. The compile function will attempt to automatically determine the blocks that are present in a file. Specifying blocks explicitly using //# has the benefit of avoiding ambiguity. If you decide to use the explicit approach, you need not read the next subsection, which explains how to write a file where the blocks are determined automatically. 2.1.1 Specifying blocks automatically All of the example files used in this documentation use the automatic approach to specifying a model. For simple models, we anticipate that the user will not need to think very much about the precise structure of the model file. Nevertheless, this section details precisely how the compiler determines the blocks present in the file. If you are interested in The compiler reads the model file from top to bottom and determines when a block is “opened” and when it is “closed”. There are multiple different types of block (some of which have subtypes), each of which is defined by containing different function types (this is fully described in section (blocks)). One of each block type can be “open” as the compiler processes the file. The first time a block of each type is encountered in the file by the compiler, a block of that type will be opened. A block is closed when either: A new block of the same type is opened. This happens when the next function type in the file is either: part of a block of the same type but of a different subtype (e.g. the current block has type “factor” and subtype “prior” and the next function type is evaluate_log_likelihood); part of a block of the same type (and subtype if this exists), and a function of this type is already in the open block (e.g. the current open block has type “factor” and subtype “prior”, containing function type evaluate_log_prior and the next function type is evaluate_log_prior). The end of the file is reached. This sounds a bit technical and might be enough to put anyone off if all they want to do is run a bit of MCMC, but the end result quite simple. If you have two functions of type evaluate_log_prior next to each other in the file, the compiler will notice that these are different factors of the joint distribution. Likewise, if you have evaluate_log_prior and evaluate_log_likelihood next to each other, the complier will also know that these are different factors. Further, if you have evaluate_log_prior, then simulate_prior, then evaluate_log_likelihood, the compiler will work out that the first two functions refer to the same prior, then the likelihood is specified by the next function. When the model is compiled, messages will be fired out to the console to tell the user when it decided each block was closed. We use the terminology “likelihood”, although in practice we will usually specify a distribution for the data given parameters.↩︎ "],["compiling.html", "2.2 Compiling an ilike file", " 2.2 Compiling an ilike file Compiling an ilike file is very simple. To compile the ilike file myfile.ilike, we call library(ilike) model = compile(&quot;myfile.ilike&quot;) The remainder of this section gives some information about what the compiler does. This is probably not of any great interest to most users, but for those who would like to know a little more, read on! The end result of the compilation is an R list that is created from the blocks in the ilike file. The different block types in the file are stored in different sublists in the compilation output. For example, an ilike file with two factor blocks (one prior with function evaluate_log_prior and one likelihood with function evaluate_log_likelihood) will compile to an R list (let’s call it model) with entries model$factor[[1]] and model$factor[[2]]. model$factor[[1]] is itself a list with, in this case, only one element model$factor[[1]]$evaluate_log_prior. This list would have two elements if additionally a simulate_prior function was specified, i.e. model$factor[[1]]$simulate_prior would also be found in the output. As expected, model$factor[[2]] is a list with one element model$factor[[2]]evaluate_log_likelihood. Each of these entries is a compiled C++ function, stored in an Rcpp::XPtr function pointer object (Eddelbuettel and François 2011). When performing inference this R list is passed into the ilike engine (which is written in C++), and the user-inputted functions are used in the relevant places. To make the R list from the file, the procedure is as follows. The ilike file is processed by the ilike compiler to produce a C++ source file. This file is then compiled by Rcpp, with the resultant Rcpp::XPtr function pointers being stored in the R list. If you would like to view the C++ source file that is compiled by Rcpp, add an argument into the compile function: model = compile(&quot;myfile.ilike&quot;, keep_temporary_model_code = TRUE) This file will be left in the working directory: its filename will be something like model_for_compilation1_2655087.cpp. The number at the end is generated at random to mitigate encountering a memory issue that leads R to crash2. References "],["C.html", "2.3 C++ functions", " 2.3 C++ functions ilike inference will be most computationally efficient if the functions are specified in C++ (or in the native ilike functions in section (ilike-functions)). The interface is designed with the aim that it is possible to use C++ functions for users with a range of different backgrounds: from those who know relatively little C++ (for whom R-like functions are provided to facilitate the process); to those who have an existing C++ code base that they would like to use to, for example, define a simulator-based model. We have already seen an example of C++ functions in section (toy-example). Here is the evaluate_log_prior function from that example. /***evaluate_log_prior***/ double prior_eval(const Parameters &amp;parameters) { arma::colvec θ = parameters[&quot;θ&quot;]; return dnorm(θ[0],0.0,10.0) + dnorm(θ[1],0.0,10.0); } If you are not familiar with C++, I imagine the main thing that looks odd to you here is the “types”, i.e. double, Parameters and arma::colvec. C++ is a typed language. In R we might write x = 1 (or probably more correctly, although I never can get into this habit myself, x&lt;-1), and then R works out that the 1 that it will store in x is a numeric type. This is invisible from the user, until for example you want to use a function that needs to take, say, a data frame, and the variable is stored as a matrix (in which case as.data_frame(…) is handy). In C++, these types must be explicitly specified in the code. We would write, for example, double x = 1.0; to specify that x has the numeric type double. Note that C++ also requires a semi-colon at the end of each line. There are several points that are worth highlighting about this function: The name of the function can be anything you like. It is a standard C++ function that, independently of being compiled by ilike would compile using a C++ compiler if all of the correct header files are included3. It has a return type (double) and argument(s) (const Parameters &amp;)4 that are pre-determined by the ilike package. The key point is that if a function under the evaluate_log_prior type does not have this return type and arguments (including the const and the &amp;), you will receive an error. The type Parameters is a class defined in the ilike package source. It operates in a similar way to an R list, or a python dictionary. There are more details about this in section (ilike-cpp-classes). arma::colvec is vector type found in the armadillo library. Any functions written to be compiled in ilike have access to this library courtesy of the R package RcppArmadillo (Eddelbuettel and Sanderson 2014). Parameter vectors are stored in the Parameters classes using armadillo matrices. The function dnorm is an C++ function provided in the ilike package for use in ilike files (or for anyone writing Rcpp code). More details about these functions can be found in section (ilike-cpp-functions). In conclusion, to write a C++ function in an ilike file: Write the header above the function. Write the C++ function with the return type and arguments required for that function type, using ilike C++ functions to help you if you need. 2.3.1 Including additional code For anything beyond a simple model, writing all of the implementation of, say, a likelihood, within a single C++ function is quite constraining. Fortunately an ilike file gives you more flexibility than this. As an example, consider an altered version of the beginning of the ilike file from section (toy-example), in which we have added a simulate_prior function to go with the evaluate_log_prior function. /***data,y=get_data()***/ /***evaluate_log_prior***/ double prior_eval(const Parameters &amp;parameters) { double prior_mean = 0.0; double prior_sd = 10.0; arma::colvec θ = parameters[&quot;θ&quot;]; return dnorm(θ[0],prior_mean,prior_sd) + dnorm(θ[1],prior_mean,prior_sd); } /***simulate_prior***/ Parameters prior_sim(RandomNumberGenerator &amp;rng) { double prior_mean = 0.0; double prior_sd = 10.0; arma::colvec simulated(2); simulated[0] = rnorm(prior_mean,prior_sd); simulated[1] = rnorm(prior_mean,prior_sd); return Parameters(&quot;θ&quot;,simulated); } In both of the functions we have set the variables prior_mean and prior_sd. It is easy to imagine that we might want to try out different prior distributions by changing the mean and/or the standard deviation, but it is just as easy to imagine that we might forget to make the change in both functions. One way we could get around this would be to specify prior_mean and prior_sd to be global variables. To do this in ilike files, you simply need to write these lines of code before any ilike functions (i.e. those with the header lines) in the file. The amended code would look like this: double prior_mean = 0.0; double prior_sd = 10.0; /***data,y=get_data()***/ /***evaluate_log_prior***/ double prior_eval(const Parameters &amp;parameters) { arma::colvec θ = parameters[&quot;θ&quot;]; return dnorm(θ[0],prior_mean,prior_sd) + dnorm(θ[1],prior_mean,prior_sd); } /***simulate_prior***/ Parameters prior_sim(RandomNumberGenerator &amp;rng) { arma::colvec simulated(2); simulated[0] = rnorm(prior_mean,prior_sd); simulated[1] = rnorm(prior_mean,prior_sd); return Parameters(&quot;θ&quot;,simulated); } Further, ilike can also use variables or functions defined in a C++ header file, where it is #included before the ilike functions. So the code could be changed to be: #include &quot;priors.h&quot; /***data,y=get_data()***/ /***evaluate_log_prior***/ double prior_eval(const Parameters &amp;parameters) { arma::colvec θ = parameters[&quot;θ&quot;]; return dnorm(θ[0],prior_mean,prior_sd) + dnorm(θ[1],prior_mean,prior_sd); } /***simulate_prior***/ Parameters prior_sim(RandomNumberGenerator &amp;rng) { arma::colvec simulated(2); simulated[0] = rnorm(prior_mean,prior_sd); simulated[1] = rnorm(prior_mean,prior_sd); return Parameters(&quot;θ&quot;,simulated); } where the file priors.h is in the working directory and contains double prior_mean = 0.0; double prior_sd = 10.0; 2.3.2 ilike C++ classes The ilike package contains one class RandomNumberGenerator used for generating random numbers, and two classes, Parameters and Data, which are used to pass parameters and data to and from the ilike inference engine. RandomNumberGenerator is a random number generator found in the dqrng R package (Stubner 2023), renamed in an attempt make it look less intimidating to the casual C++ user. For the remainder of the section, we focus on describing the Parameters class (Data has the same functionality). The Parameters class can be thought of as being similar to an R list or python dictionary, where each element is indexed by a std::string key, and each element has the type arma::mat (a matrix, from the armadillo library). Full documentation for this class can be found in the Parameters file in the ilike cpp documentation. The file itself can be found in the package inst/include directory. Here we describe the most commonly used functions. 2.3.2.1 Constructors Parameters(); This constructs an empty Parameters object. Parameters(const std::string &amp;variable_in, double value_in); This constructs a Parameters object with the given double stored in a \\(1\\times 1\\) dimensional arma::mat matrix, indexed by the key given by the std::string. Parameters(const std::string &amp;variable_in, const arma::mat &amp;value_in); This constructs a Parameters object with the given arma::mat stored in the Parameters object with index by the key given by the std::string. An arma::colvec can also be supplied as an argument to this function, with the armadillo library dealing with the conversion between the types. 2.3.2.2 Element access arma::mat&amp; operator[](const std::string &amp;variable); arma::mat operator[](const std::string &amp;variable) const; These functions allow: (a) the assignment to an existing Parameters object of a new arma::mat, indexed by the key given by the std::string; and (b) accessing in a Parametersobject the arma::mat, indexed by the key given by the std::string. For example, to store a column vector with the key \"x\": arma::colvec a_vector(2); a_vector[0] = 1.0; a_vector[1] = 4.0; Parameters parameters; parameters[&quot;x&quot;] = a_vector; Then, to subsequently access the vector in the parameters object: arma::colvec x = parameters[&quot;x&quot;]; 2.3.2.3 Copying Parameters(const Parameters &amp;another); Parameters&amp; operator=(const Parameters &amp;another); These functions allow a parameters object to be copied, using a copy constructor and an operator= respectively. Examples of each follow: // using a copy constructor to copy the object &quot;parameters&quot;, which was defined in the previous code chunk Parameters copied_parameters(parameters); // using operator= to copy &quot;parameters&quot; Parameters another_copied_parameters = parameters; 2.3.2.4 Combining Parameters merge(const Parameters &amp;another) const; This function combines two Parameters objects into one. Each element in the object taken as an argument is inserted only if its key is not equivalent to the key of any other element already in the container. For example: // make more vectors to store in a Parameters object arma::colvec b_vector(1); b_vector[0] = 5.0; arma::colvec c_vector(1); c_vector[0] = 12.0; // make another Parameters object that we will merge with the one we made above. Parameters more_parameters; more_parameters[&quot;x&quot;] = b_vector; more_parameters[&quot;y&quot;] = c_vector; // perform the merge // both parameters and more_parameters have the key &quot;x&quot;, // so the &quot;x&quot; element from parameters, // and the &quot;y&quot; element from more_parameters are found in the result Parameters yet_more_parameters = parameters.merge(more_parameters); 2.3.2.5 Printing std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const Parameters &amp;p); This function prints a Parameters object to an output stream. For example, to print to console: std::cout &lt;&lt; parameters; 2.3.3 ilike C++ functions Functions from any C++ library may be used to simplify the writing of an ilike file, provided the functions being used are found in header files only. The boost library is particularly easy to use in this setting, since most of the boost header files are available directly through ilike’s depdendece on the BH R package (Eddelbuettel, Emerson, and Kane 2024). ilike itself contains a number of C++ functions that might be useful. Most of these provide methods for simulating points from, or evaluating the density of. various commonly used distributions. The arguments taken bv these functions are chosen to be, where possible, roughly consistent with the corresponding functions in R. All functions involving the simulation of random points require a RandomNumberGenerator as their first argument (most provide an interface to the corresponding functions in boost). The use of a RandomNumberGenerator distinguishes these functions from those found in Rcpp. Use of the ilike functions is recommended in ilike files, to ensure correct handling of the random number streams in the ilike inference engine. Casual C++ users may not be familiar with the type size_t: this can be thought of as a non-negative integer. 2.3.3.1 hz test double hz(const arma::mat &amp;data_in) Implements Henze-Zirkler’s test for multivariate linearity: a translation into C++ of the code found in the MVN R package (Korkmaz, Goksuluk, and Zararsiz 2014). 2.3.3.2 log-sum-exp double log_sum_exp(const arma::colvec &amp;log_weights) This function implements the LogSumExp trick on the inputted vector. 2.3.3.3 Weighted mean and covariance arma::rowvec mean_wt(const arma::mat &amp;x, const arma::colvec &amp;wt); arma::mat cov_wt(const arma::mat &amp;x, const arma::colvec &amp;wt); The functions compute the weighted (using weight wt) mean and covariance of the data found in the rows of x. The vector wt needs to be normalised. 2.3.3.4 Discrete distribution size_t rdis(RandomNumberGenerator &amp;rng, const arma::colvec &amp;probabilities); Generates a random number from the discrete distribution taking values \\([0,n)\\), with probabilities given by the vector probabilities, and n being taken to be the length of this vector. The vector probabilities need not be normalised. arma::uvec multiple_rdis(RandomNumberGenerator &amp;rng, size_t n, const arma::colvec &amp;probabilities); Generates n random numbers from the discrete distribution taking values \\([0,n)\\), with probabilities given by the vector probabilities, and n being taken to be the length of this vector. The vector probabilities need not be normalised. 2.3.3.5 Exponential distribution double rexp(RandomNumberGenerator &amp;rng, double rate); Generates a random number from the exponential distribution with rate rate. arma::colvec rexp(RandomNumberGenerator &amp;rng, size_t n, double rate); Generates n random numbers from the exponential distribution with rate rate. double dexp(double x, double rate); Evaluates the log of the exponential density with rate rate at the point x. double rtranslatedexp(RandomNumberGenerator &amp;rng, double rate, double min); Generates a random number from the translated (by min) exponential distribution with rate rate. arma::colvec rtranslatedexp(RandomNumberGenerator &amp;rng, size_t n, double rate, double min); Generates n random numbers from the translated (by min) exponential distribution with rate rate. double dtranslatedexp(double x, double rate, double min); Evaluates the log of the translated exponential (by min) density with rate rate at the point x. 2.3.3.6 Gamma distribution double rgamma(RandomNumberGenerator &amp;rng, double shape, double rate); Generates a random number from the gamma distribution with shape shape and rate rate. arma::colvec rgamma(RandomNumberGenerator &amp;rng, size_t n, double shape, double rate); --- Generates n random numbers from the gamma distribution with shape shape and rate rate. double dgamma(double x, double shape, double rate); Evaluates the log of the gamma density with shape shape and rate rate at the point x. 2.3.3.7 Log-normal and multivariate log-normal distribution double rlnorm(RandomNumberGenerator &amp;rng, double meanlog, double sdlog) { boost::random::lognormal_distribution&lt;double&gt; my_gamma(meanlog, sdlog); return my_gamma(rng); } Generates a random number from the log-normal distribution with mean of the log of the variable meanlog and standard deviation of the log of the variable sdlog. arma::colvec rlnorm(RandomNumberGenerator &amp;rng, size_t n, double meanlog, double sdlog); Generates n random numbers from the log-normal distribution with mean of the log of the variable meanlog and standard deviation of the log of the variable sdlog. double dlnorm(double x, double meanlog, double sdlog) { if (sdlog&lt;0) { return NAN; } if (sdlog==0) { if (x==meanlog) return arma::datum::inf; else return -arma::datum::inf; } return - log(x) - log(sdlog) - 0.5*log(2.0*M_PI) - 0.5*pow((log(x)-meanlog)/sdlog,2.0); } Evaluates the log of the log-normal density with mean of the log of the variable meanlog and standard deviation of the log of the variable sdlog at the point x. arma::colvec rmvlnorm(RandomNumberGenerator &amp;rng, const arma::colvec &amp;mulog, const arma::mat &amp;Sigmalog); Generates a random number from the multivariate log-normal distribution with mean of the log of the variable meanlog and covariance of the log of the variable Sigmalog. double dmvlnorm(const arma::colvec &amp;x, const arma::colvec &amp;mulog, const arma::mat &amp;Sigmalog) double dmvlnorm_using_precomp(const arma::colvec &amp;x, const arma::colvec &amp;mulog, const arma::mat &amp;inv_Sigmalog, double log_det) Evaluates the log of the multivariate log-normal density with mean of the log of the variable meanlog and covariance of the log of the variable Sigmalog at the point x. The latter function does not require the covariance as an argument: instead it takes the inverse of the covariance inv_Sigma and the log of the determinant of the covariance (log_det). This is designed for cases where the density needs to be evaluated at a number of points using the same covariance; using this function avoids performing the most expensive parts of the computation more than once. 2.3.3.8 Normal/Gaussian and multivariate normal/Gaussian distribution double rnorm(RandomNumberGenerator &amp;rng); Generates a random number from the standard normal distribution. arma::mat rnorm(RandomNumberGenerator &amp;rng, size_t n); Generates n random numbers from the standard normal distribution. arma::mat rnorm(RandomNumberGenerator &amp;rng, std::pair&lt;size_t,size_t&gt; dimensions); Generates a matrix (of dimension given by dimensions) of random numbers from the standard normal distribution. double dnorm(double x); Evaluates the log of the standard normal density at the point x. double rnorm(RandomNumberGenerator &amp;rng, double mean, double sd); Generates a random number from the normal distribution with mean mean and standard deviation sd. arma::mat rnorm(RandomNumberGenerator &amp;rng, size_t n, double mean, double sd); Generates n random numbers from the normal distribution with mean mean and standard deviation sd. arma::mat rnorm(RandomNumberGenerator &amp;rng, std::pair&lt;size_t,size_t&gt; dimensions, double mean, double sd); Generates a matrix (of dimension given by dimensions) of random numbers from the normal distribution with mean mean and standard deviation sd. double dnorm(double x, double mean, double sd); Evaluates the log of the normal density with mean mean and standard deviation sd at the point x. arma::colvec dnorm(const arma::colvec &amp;x, double mean, double sd); arma::colvec dnorm(const arma::colvec &amp;x, const arma::colvec &amp;mean, double sd); arma::colvec dnorm(const arma::colvec &amp;x, double mean, const arma::colvec &amp;sd); arma::colvec dnorm(const arma::colvec &amp;x, const arma::colvec &amp;mean, const arma::colvec &amp;sd); Evaluates the log of the normal density with mean mean and standard deviation sd at the vector of points x, returning a vector. If mean and/or sd are a double, the same mean/sd is used for all dimensions; if a vector the corresponding entry in that vector is used for each dimension. arma::colvec rmvnorm(RandomNumberGenerator &amp;rng, const arma::colvec &amp;mu, const arma::mat &amp;Sigma); Generates a random vector from the multivariate normal distribution with mean mu and covariance Sigma. arma::mat rmvnorm(RandomNumberGenerator &amp;rng, size_t n, const arma::colvec &amp;mu, const arma::mat &amp;Sigma); Generates n random vectors from the multivariate normal distribution with mean mu and covariance Sigma, stored in a \\(d\\times n\\) matrix, where \\(d\\) is the dimension of the multivariate Gaussian (determined by the size of the inputted mean and covariance). double dmvnorm(const arma::colvec &amp;x, const arma::colvec &amp;mu, const arma::mat &amp;Sigma); double dmvnorm_using_precomp(const arma::colvec &amp;x, const arma::colvec &amp;mu, const arma::mat &amp;inv_Sigma, double log_det); Evaluates the log of the multivariate normal density with mean mu and covariance Sigma at the vector x. The latter function does not require the covariance as an argument: instead it takes the inverse of the covariance inv_Sigma and the log of the determinant of the covariance (log_det). This is designed for cases where the density needs to be evaluated at a number of points using the same covariance; using this function avoids performing the most expensive parts of the computation more than once. 2.3.3.9 Truncated normal/Gaussian and trucated multivariate normal/Gaussian distributions double rtnorm(RandomNumberGenerator &amp;rng, double min, double max); Generates a random number from the standard truncated normal distribution, with bounds given by min and max (using the technique from Robert (1995)). arma::mat rtnorm(RandomNumberGenerator &amp;rng, size_t n, double min, double max); Generates n random numbers from the standard truncated normal distribution, with bounds given by min and max (using the technique from Robert (1995)). arma::mat rtnorm(RandomNumberGenerator &amp;rng, std::pair&lt;size_t,size_t&gt; dimensions, double min, double max); Generates a matrix (of dimension given by dimensions) of random numbers from the standard truncated normal distribution, with bounds given by min and max (using the technique from Robert (1995)). double dtnorm(double x, double min, double max); Evaluates the log of the standard truncated normal density, with bounds given by min and max, at the point x. double rtnorm(RandomNumberGenerator &amp;rng, double mean, double sd, double min, double max); Generates a random number from the truncated normal distribution with mean mean and standard deviation sd, with bounds given by min and max. arma::mat rtnorm(RandomNumberGenerator &amp;rng, size_t n, double mean, double sd, double min, double max); Generates n random numbers from the truncated normal distribution with mean mean and standard deviation sd, with bounds given by min and max. arma::mat rtnorm(RandomNumberGenerator &amp;rng, std::pair&lt;size_t,size_t&gt; dimensions, double mean, double sd, double min, double max); Generates a matrix (of dimension given by dimensions) of random numbers from the truncated normal distribution with mean mean and standard deviation sd, with bounds given by min and max. double dtnorm(double x, double mean, double sd, double min, double max); Evaluates the log of the truncated normal density with mean mean and standard deviation sd, with bounds given by min and max, at the point x. arma::colvec dtnorm(const arma::colvec &amp;x, double mean, double sd, double min, double max); Evaluates the log of the truncated normal density with mean mean and standard deviation sd, with bounds given by min and max, at the vector of points x, returning a vector. arma::colvec rtmvnorm(RandomNumberGenerator &amp;rng, const arma::colvec &amp;mu, const arma::mat &amp;Sigma, const arma::colvec &amp;min, const arma::colvec &amp;max); Generates a random vector from the truncated multivariate normal distribution with mean mu and covariance Sigma, with bounds given by min and max. A simple rejection sampler is used for the implementation. arma::mat rtmvnorm(RandomNumberGenerator &amp;rng, size_t n, const arma::colvec &amp;mu, const arma::mat &amp;Sigma, const arma::colvec &amp;min, const arma::colvec &amp;max); Generates n random vectors from the truncated multivariate normal distribution with mean mu and covariance Sigma, with bounds given by min and max, stored in a \\(d\\times n\\) matrix, where \\(d\\) is the dimension of the multivariate Gaussian (determined by the size of the inputted mean and covariance). 2.3.3.10 Poisson distribution int rpois(RandomNumberGenerator &amp;rng, double rate); Generates a random number from the Poisson distribution with rate rate. arma::colvec rpois(RandomNumberGenerator &amp;rng, size_t n, double rate); Generates n random numbers from the Poisson distribution with rate rate. double dpois(double x, double rate); Evaluates the log of the Poisson mass function with rate rate at the point x. 2.3.3.11 Uniform distribution (continuous) double runif(RandomNumberGenerator &amp;rng); Generates a random number from the uniform distribution between 0 and 1. double runif(RandomNumberGenerator &amp;rng, double lower, double upper); Generates a random number from the uniform distribution between lower and upper. arma::mat runif(RandomNumberGenerator &amp;rng, const arma::mat &amp;lower, const arma::mat &amp;upper); Generates a matrix of random numbers, where the \\((i,j)\\)th element is drawn from the uniform distribution between the \\((i,j)\\)th element of lower and the \\((i,j)\\)th element of upper. arma::rowvec multiple_runif(RandomNumberGenerator &amp;rng, size_t n); Generates n random numbers from the uniform distribution between 0 and 1, and stores them in a row vector. arma::rowvec multiple_runif(RandomNumberGenerator &amp;rng, size_t n, double lower, double upper); Generates n random numbers from the uniform distribution between lower and upper, and stores them in a row vector. double dunif(double x); Evaluates the log of the uniform density between 0 and 1 at x. double dunif(double x, double lower, double upper); Evaluates the log of the uniform density between lower and upper at x. double dunif(const arma::mat &amp;x, const arma::mat &amp;lower, const arma::mat &amp;upper); For the \\((i,j)\\)th element of x, evaluate the log of the uniform density between the \\((i,j)\\)th element of lower and the \\((i,j)\\)th element of upper, then take the sum of the result (i.e. the product of independent uniform densities). References "],["R.html", "2.4 R functions", " 2.4 R functions "],["python.html", "2.5 python functions", " 2.5 python functions "],["julia.html", "2.6 julia functions", " 2.6 julia functions "],["ilike-functions.html", "2.7 ilike functions", " 2.7 ilike functions "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
