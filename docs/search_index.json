[["models.html", "Chapter 4 Models", " Chapter 4 Models The section describes how to specify a model in an ilike file. A model is specified through factors, the product of which defines a (possibly unnormalised) joint distribution1. In most situations we envisage users will be using ilike to perform inference conditional on observed data: in these cases the use must specify a function for ilike to load the data. Factors can either be of the type prior or likelihood. A prior factor is any distribution that does not depend on observed data. Conditional distributions where none of the variables are observed would fall under this category. A likelihood factor is a distribution where one or more of the variables involved is observed. To illustrate the distinction, consider a hierarchical model of the form \\[ p(\\phi) f(\\theta \\mid \\phi) g(y \\mid \\theta). \\] If we wish to perform inference on \\(\\theta\\) and \\(\\phi\\) given observed \\(y\\), then \\(p(\\phi)\\) and \\(f(\\theta \\mid \\phi)\\) would be specified as prior factors, and \\(g(y \\mid \\theta)\\) would be specified as a likelihood factor. If, for whatever reason, we wished to construct, say, an MCMC algorithm for simulating from the joint distribution on \\(\\phi\\), \\(\\theta\\) and \\(y\\), then all three could be specified as “priors”. The specification of a state-space model, which involves a time index \\(t\\) and requires the specification of a transition model, is not described in this section: these details can be found in section 7. There are two ways of specifying priors: through user-defined functions, or through simple built-in “ilike” functions. For a likelihood, the specification through user-defined functions closely follows the analogous way of specifying a prior. The built-in choices of likelihood can be categorised as follows: linear and non-linear Gaussian models, covering the special case of measurements with Gaussian noise; simulation-based likelihoods, allowing the use of data models that are specified in the form of a simulator; algorithmic likelihoods, where the likelihood is given by an algorithm such as a particle filter. Recall that every entry in an ilike file has a “function type”. This section details every function type that may be used to specify a model: each subsubsection (e.g. 3.1.1) is named after a function type. For user-defined function types we detail the input and output arguments of the function, and give an example of its use. The specification of each function type is described in both C++ and R. Python and Julia function are both called from R - see section 3 - so do not require further description). For built-in (ilike) function types, we detail each available built-in function in subsubsubsections (e.g. 3.2.1.1). The order in which the factors are provided in the ilike file does not matter, but the compiler will allocate a number to each in the order they are provided, starting from 1. Some parts of the algorithm specification (e.g. specifying which factors must be evaluated in a Metropolis-Hastings update) require the user to refer to factors by their number, so the user may wish to use comments in the ilike file (through the C++ commenting style, i.e. // or /* */) to keep track of the factor numbers. The compiler makes no checks as to whether the factors provided define a valid joint distribution: responsibility for this is left to the user.↩︎ "],["data.html", "4.1 Data", " 4.1 Data 4.1.1 data The data function type returns observed data. There are no input arguments. Output: The observed data. – of class Data in a C++ function – an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an = sign in the function header. C++ example: /***data***/ Data set_data() { arma::colvec y(2,1); y[0] = 1.0; y[1] = 2.0; return Data(&quot;y&quot;, y); } R example: /***data,y=c(1,2)***/ "],["user-defined-prior.html", "4.2 User-defined prior", " 4.2 User-defined prior A user-defined prior is specified through some combination of function types (e.g. evaluate_log_prior, simulate_prior). The user only needs to specify the function types required by the algorithm they wish to use. For example: – evaluate_log_prior for Metropolis-Hastings where the prior needs to be evaluated in the acceptance ratio; – simulate_prior for importance sampling where the prior is used as the proposal, and the prior cancels and does not need to be evaluated in the weight update; – evaluate_gradient_log_prior for an unadjusted Langevin MCMC which requires the gradient of the prior to make moves. We now describe the available function types. 4.2.1 evaluate_log_prior The evaluate_log_prior function type calculates the log prior density of the parameters. Input: The point at which the log of the prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The log prior density of the parameters. – of type double in a C++ function – of type numeric in R. C++ example: /***evaluate_log_prior***/ double prior_eval(const Parameters &amp;parameters) { return dnorm(parameters[&quot;θ&quot;][0]); } R example: /***evaluate_log_prior,dnorm(parameters$θ,log=TRUE)***/ 4.2.2 simulate_prior The simulate_prior function type samples from the prior distribution. Input: (C++ only) The random number generator. – of type RandomNumberGenerator &amp; in a C++ function Output: The simulated value. – of class Parameters in a C++ function – an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an = sign in the function header. C++ example: /***simulate_prior***/ Parameters prior_sim(RandomNumberGenerator &amp;rng) { return Parameters(&quot;θ&quot;,rnorm(rng)); } R example: /***simulate_prior,θ=rnorm(1)***/ 4.2.3 evaluate_gradient_log_prior The evaluate_gradient_log_prior function type gives the differential of the log prior density of the parameters. Input: The variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable in an R function Input: The point at which the gradient of the log prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The gradient of the log prior density of the parameters. – of type arma::mat in a C++ function – of type matrix in R. C++ example: /***evaluate_gradient_log_prior***/ arma::mat prior_gradient_eval(const std::string &amp;variable, const Parameters &amp;parameters) { if (variable==&quot;θ&quot;) { arma::mat grad(1,1); grad(0,0) = -parameters[&quot;θ&quot;][0]; return grad; } else { Rcpp::stop(&quot;Unknown variable in prior gradient.&quot;); } } R example: /***evaluate_gradient_log_prior,if (variable==&quot;θ&quot;) {-parameters$θ} else {stop(&quot;Unknown variable in prior gradient.&quot;)}***/ 4.2.4 evaluate_second_gradient_log_prior The evaluate_gradient_log_prior function type gives the second differential of the log prior density of the parameters. Input: The first variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable1 in an R function Input: The second variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable2 in an R function Input: The point at which the gradient of the log prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The Hessian of the log prior density, evaluated at the given point. – of type arma::mat in a C++ function – of type matrix in R C++ example: /***evaluate_second_gradient_log_prior***/ arma::mat prior_gradient_eval(const std::string &amp;variable1, const std::string &amp;variable2, const Parameters &amp;parameters) { if ((variable1==&quot;θ&quot;) &amp;&amp; (variable2==&quot;θ&quot;)) { arma::mat grad(1,1); grad(0,0) = -1.0; return grad; } else { Rcpp::stop(&quot;Unknown variable in prior second gradient.&quot;); } } R example: /***evaluate_second_gradient_log_prior,if ((variable1==&quot;θ&quot;) &amp;&amp; (variable2==&quot;θ&quot;)) {-1} else {stop(&quot;Unknown variable in prior second gradient.&quot;)}***/ "],["ilike-prior.html", "4.3 Built-in prior", " 4.3 Built-in prior 4.3.1 prior The prior function type allows the user to specify the prior through an ilike function (e.g. ilike::norm). For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted. Example of the use of one of these functions (ilike::norm) follows. /***prior,ilike::norm(θ,0,1)***/ The following sections detail the available ilike functions. 4.3.1.1 Normal prior ilike::norm Specifies a normal prior over the given variable, with the given parameters. Inputs: string: the variable for which the prior is specified numeric: the mean of the normal distribution numeric: the standard deviation of the normal distribution 4.3.1.2 Multivariate normal prior ilike::mvnorm Specifies a multivariate normal prior over the given variable, with the given parameters. Inputs: string: the variable for which the prior is specified numeric vector/matrix: the mean of the multivariate normal distribution matrix: the covariance of the multivariate normal distribution 4.3.1.3 Lognormal prior ilike::lnorm Specifies a lognormal prior over the given variable, with the given parameters. Inputs: string: the variable for which the prior is specified numeric: the mean of the log of the variable numeric: the standard deviation of the log of the variable 4.3.1.4 Multivariate lognormal prior ilike::mvlnorm Specifies a multivariate loggnormal prior over the given variable, with the given parameters. Inputs: string: the variable for which the prior is specified numeric vector/matrix: the mean of the log of the variable matrix: the covariance of the log of the variable 4.3.1.5 Gamma prior ilike::gamma Specifies a gamma prior over the given variable, with the given parameters. Inputs: string: the variable for which the prior is specified numeric: the shape of the gamma distribution numeric: the rate of the gamma distribution "],["user-defined-likelihood.html", "4.4 User-defined likelihood", " 4.4 User-defined likelihood The functions in this section allow the specification of a user-defined likelihood. Only the functions required by the chosen inference algorithm need be specified. 4.4.1 evaluate_log_likelihood The evaluate_log_likelihood function type calculates the log likelihood of the parameters. Input: The point at which the log likelihood is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Input: The observed data for which the log likelihood is to be evaluated. – of type const Data &amp; in a C++ function – available as R list data in an R function Output: The log likelihood of the parameters using the observed data. – of type double in a C++ function – of type numeric in R. C++ example: /***evaluate_log_likelihood***/ double likelihood_eval(const Parameters &amp;parameters, const Data &amp;data) { double y = data[&quot;y&quot;]; return sum(dnorm(y,parameters[&quot;θ&quot;][0],1.0)); } R example: /***evaluate_log_likelihood,sum(dnorm(data$y,parameters$θ,1.0,log=TRUE))***/ 4.4.2 evaluate_gradient_log_likelihood The evaluate_gradient_log_likelihood function type calculates the gradient of the log likelihood of the parameters. Input: The variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable in an R function Input: The point at which the gradient of the log likelihood is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Input: The observed data for which the gradient of the log likelihood is to be evaluated. – of type const Data &amp; in a C++ function – available as R list data in an R function Output: The gradient of the log likelihood of the parameters. – of type arma::mat in a C++ function – of type matrix in R. C++ example: /***evaluate_gradient_log_likelihood***/ arma::mat likelihood_gradient_eval(const std::string &amp;variable, const Parameters &amp;parameters, const Data &amp;data) { if (variable==&quot;θ&quot;) { arma::colvec y = data[&quot;y&quot;]; arma::mat grad(1,1); grad(0,0) = arma::sum((y-parameters[&quot;θ&quot;][0])/1.0); return grad; } else { Rcpp::stop(&quot;Unknown variable in likelihood gradient.&quot;); } } R example: /***evaluate_gradient_log_likelihood,if (variable==&quot;θ&quot;) {sum((data$y-parameters$θ)/1.0)} else {stop(&quot;Unknown variable in likelihood gradient.&quot;)}***/ 4.4.3 evaluate_second_gradient_log_likelihood The evaluate_gradient_log_prior function type gives the second differential of the log likelihood of the parameters. Input: The first variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable1 in an R function Input: The second variable with respect to which we wish to find the gradient. – of type const std::string &amp; in a C++ function – available an R string variable2 in an R function Input: The point at which the gradient of the log prior is to be evaluated. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The Hessian of the log likelihood, evaluated at the given point. – of type arma::mat in a C++ function – of type matrix in R. C++ example: /***evaluate_second_gradient_log_likelihood***/ arma::mat likelihood_hessian_eval(const std::string &amp;variable1, const std::string &amp;variable2, const Parameters &amp;parameters, const Data &amp;data) { if (variable1==&quot;θ&quot; &amp;&amp; variable2==&quot;θ&quot;) { arma::mat hess(1,1); hess(0,0) = -data[&quot;y&quot;].size()/1.0; return hess; } else { Rcpp::stop(&quot;Unknown variable in likelihood hessian.&quot;); } } R example: /***evaluate_second_gradient_log_likelihood,if (variable1==&quot;θ&quot; &amp;&amp; variable2==&quot;θ&quot;) {-length(data$y)/1.0} else {stop(&quot;Unknown variable in likelihood hessian.&quot;)}***/ "],["linear-gaussian-model.html", "4.5 Linear-Gaussian model", " 4.5 Linear-Gaussian model A commonly-used class of model is one where data \\(y\\) arises from a linear function of some latent state, plus some Gaussian noise, i.e. \\[ y \\sim \\mathcal{MVN}(H x, R) \\tag{4.1} \\] where \\(H\\) is a matrix and \\(R\\) is a covariance matrix. The linear-Gaussian data model subtype allows the specification of such model, through providing the variable names (\\(y\\) and \\(x\\) here) and the values for \\(H\\) and \\(R\\). Note that, using this block subtype, it would be possible to specify a model for a number of independent observations from a Gaussian distribution. However, this would be an inefficient way of specifying this model since it would require the user to supply a large diagonal covariance matrix. Such a model would be more effectively specified via the exact_likelihood block sutype. There are two ways of specifying a linear-Gaussian data model: Through the function types linear_gaussian_data_variable (specifying the name of the \\(y\\) variable), linear_gaussian_data_state_variable (specifying the name of the \\(x\\) variable), linear_gaussian_data_matrix (specifying the \\(A\\) matrix), and linear_gaussian_data_covariance (specifying the name of the \\(\\Sigma\\) matrix), The user needs to provide all of these functions in order to fully specify the model. Through the function type linear_gaussian_data_model, which allows the user to specify the complete model through an ilike function. We now detail the function types. 4.5.1 linear_gaussian_data_variable Specifies the name of the observed data variable in the linear-Gaussian data model. There are no input arguments. Output: The name of the variable used as \\(y\\) in equation (4.1). – of type const std::string &amp; in a C++ function – a string in R. C++ example: /***linear_gaussian_data_variable***/ std::string set_data_variable() { return &quot;y&quot;; } R example: /***linear_gaussian_data_variable,&quot;y&quot;***/ 4.5.2 linear_gaussian_data_state_variable Specifies the name of the latent state variable in the linear-Gaussian data model. There are no input arguments. Output: The name of the variable used as \\(x\\) in equation (4.1). – of type const std::string &amp; in a C++ function – a string in R. C++ example: /***linear_gaussian_data_state_variable***/ std::string set_state_variable() { return &quot;x&quot;; } R example: /***linear_gaussian_data_state_variable,&quot;x&quot;***/ 4.5.3 linear_gaussian_data_matrix Specifies the matrix \\(A\\) in the linear-Gaussian data model. Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The matrix \\(A\\) in equation (4.1). – of type arma::mat in a C++ function – a matrix in R. C++ examples: /***linear_gaussian_data_matrix***/ arma::mat set_matrix() { arma::mat A(2,2); A(0,0) = 1.0; A(0,1) = 0.0; A(1,0) = 0.0; A(1,1) = 1.0; return A; } or /***linear_gaussian_data_matrix***/ arma::mat set_matrix(const Parameters &amp;parameters) { double scale = parameters[&quot;scale&quot;][0]; arma::mat A(2,2); A(0,0) = scale; A(0,1) = 0.0; A(1,0) = 0.0; A(1,1) = scale; return A; } R example: /***linear_gaussian_data_matrix,diag(2)***/ or /***linear_gaussian_data_matrix,parameters$scale*diag(2)***/ 4.5.4 linear_gaussian_data_covariance Specifies the covariance matrix \\(R\\) in the linear-Gaussian data model. Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The covariance matrix \\(R\\) in equation (4.1). – of type arma::mat in a C++ function – a matrix in R C++ examples: /***linear_gaussian_data_covariance***/ arma::mat set_covariance() { arma::mat R(2,2); R(0,0) = 1.0; R(0,1) = 0.0; R(1,0) = 0.0; R(1,1) = 1.0; return R; } or /***linear_gaussian_data_covariance***/ arma::mat set_covariance(const Parameters &amp;parameters) { double scale = parameters[&quot;scale&quot;][0]; arma::mat R(2,2); R(0,0) = scale; R(0,1) = 0.0; R(1,0) = 0.0; R(1,1) = scale; return R; } R examples: /***linear_gaussian_data_covariance,diag(2)***/ or /***linear_gaussian_data_covariance,parameters$scale*diag(2)***/ 4.5.5 linear_gaussian_data_model We may use an ilike function to specify the complete linear-Gaussian data model. 4.5.5.1 Linear-Gaussian data model ilike::linear_gaussian_data_model Specifies the linear-Gaussian data model. Inputs: string: The name of the observed data variable string: The name of the latent state variable matrix: The matrix \\(A\\) matrix: The covariance matrix \\(R\\) "],["nonlinear-gaussian-model.html", "4.6 Nonlinear-Gaussian model", " 4.6 Nonlinear-Gaussian model The nonlinear-Gaussian data model subtype may be used to specify a model where data \\(y\\) arises from a nonlinear function of some latent state, plus some Gaussian noise, i.e. \\[ y \\sim \\mathcal{N}(g(x), R) \\tag{4.2} \\] where \\(g\\) is a function and \\(R\\) is a covariance matrix. To specify the model we need to provide the variable name (\\(y\\)), the function \\(g\\) and the matrix \\(R\\). To do this the user must provide three function types, respectively: nonlinear_gaussian_data_variable, nonlinear_gaussian_data_function and nonlinear_gaussian_data_covariance. 4.6.1 nonlinear_gaussian_data_variable Specifies the name of the observed data variable. There are no input arguments. Output: The name of the observed data variable. – of type const std::string &amp; in a C++ function – a string in R. C++ example: /***nonlinear_gaussian_data_variable***/ std::string set_variable() { return &quot;y&quot;; } R example: /***nonlinear_gaussian_data_variable,&quot;y&quot;***/ 4.6.2 nonlinear_gaussian_data_function Specifies the function \\(g\\) in the nonlinear-Gaussian data model. Input: The state \\(x\\) and any parameters that the function relies on (the latter may be included to allow the specification of a parameter-dependent function) – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The output of the function \\(g\\) in equation (4.2). – of type const Data &amp; in a C++ function – a list in R. C++ example: /***nonlinear_gaussian_data_function***/ Data transform_into_data_space(const Parameters &amp;x_and_theta) { arma::colvec noiseless_y(1,1); noiseless_y[0] = exp(x_and_theta[&quot;x&quot;][0) + x_and_theta[&quot;theta&quot;][0]; return Data(&quot;y&quot;, noiseless_y); } R example: /***nonlinear_gaussian_data_function,y=exp(parameters$x)+parameters$theta***/ 4.6.3 nonlinear_gaussian_data_covariance Specifies the covariance matrix \\(R\\) in the nonlinear-Gaussian data model. Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The covariance matrix \\(R\\) in equation (4.2). – of type arma::mat in a C++ function – a matrix in R. C++ examples: /***nonlinear_gaussian_data_covariance***/ arma::mat set_covariance() { arma::mat R(2,2); R(0,0) = 1.0; R(0,1) = 0.0; R(1,0) = 0.0; R(1,1) = 1.0; return R; } or /***nonlinear_gaussian_data_covariance***/ arma::mat set_covariance(const Parameters &amp;parameters) { double scale = parameters[&quot;scale&quot;][0]; arma::mat R(2,2); R(0,0) = scale; R(0,1) = 0.0; R(1,0) = 0.0; R(1,1) = scale; return R; } R examples: /***nonlinear_gaussian_data_covariance,diag(2)***/ or /***nonlinear_gaussian_data_covariance,parameters$scale*diag(2)***/ "],["simulation-based-likelihood.html", "4.7 Simulation-based likelihood", " 4.7 Simulation-based likelihood The functions in this section allow the specification of a likelihood through a function that simulates a data generating process, for example through approximate Bayesian computation. There are three function types that are required to be specified for all simulation-based likelihoods: simulate_data_model, which simulates the data generating process. data_variable, which specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. sbi_likelihood, which uses an ilike function to define the desired simulation-based likelihood. It is also possible to reduce the observed data to summary statistcs (though the use of the summary_statistics function type) for use in the simulation-based likelihood. 4.7.1 simulate_data_model The simulate_data_model function type simulates the data generating process. Input: (C++ only) The random number generator to be used in the simulation. – of type RandomNumberGenerator &amp; in a C++ function Input: The parameters at which to simulate the data. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Output: The simulated data. – of class Data in a C++ function – an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an = sign in the function header. C++ example: /***simulate_data_model***/ Data simulate_data_model(RandomNumberGenerator &amp;rng, const Parameters &amp;parameters) { arma::colvec y = rnorm(rng,100,parameters[&quot;θ&quot;][0],1.0); return Data(&quot;y&quot;, y); } R example: /***simulate_data_model,y=rnorm(100,parameters$θ,1)***/ 4.7.2 data_variable The data_variable function type specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. If summary statistics are being used, this should be the variables used in the summary statistics, rather than those in the data. There are no input arguments. Output: The variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. To specify multiple output variables they must be separated by a semi-colon (with no spaces). – of type const std::string &amp; in a C++ function – a string in R. C++ example: /***data_variable***/ std::string a_variable() { return &quot;y&quot;; // could be &quot;y;z&quot; for variables y and z } R example: /***data_variable,&quot;y&quot;***/ 4.7.3 summary_statistics The summary_statistics function type reduces the observed data to summary statistics for use in the simulation-based likelihood. The inclusion of this function type is optional: if it is included, then inference using the simulation-based likelihood will be conditional only on the summary statistics of the data, rather than the full data. If the argument is omitted, the simulation-based likelihood will use the full data. Input: Simulated/observed data. – of type const Data &amp; in a C++ function – available as R list data in an R function Output: The summary statistics of the data. – of type const Data &amp; in a C++ function – available as R list data in an R function C++ example: /***summary_statistics***/ Data summary_statistics(const Data &amp;data) { arma::colvec y = data[&quot;y&quot;]; return Data(&quot;y_mean&quot;, arma::mean(y)); } R example: /***summary_statistics,y_mean=mean(data$y)***/ 4.7.4 sbi_likelihood The sbi_likelihood function type uses an ilike function to define the desired simulation-based likelihood. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted. Example of the use of one of these functions (ilike::sl) follows. /***sbi_likelihood,ilike::sl(50)***/ All of these methods use simulations from the data generating process (DGP) to construct an approximate likelihood from data \\(y_{\\mbox{obs}}\\). \\(s_{\\mbox{obs}}\\) is used to denote the result of applying the summary_statistic function to \\(y_{\\mbox{obs}}\\). Let \\(y^{1:M}\\) be \\(M\\) draws from the DGP \\(f(\\cdot \\mid \\theta)\\) for parameter \\(\\theta\\) and let \\(s^{1:M}\\) be the result of applying the summary_statistic function to each corresponding simulation. Suppose that each summary statistic lies in \\(\\mathbb{R}^{d_s}\\): this vector is the result of stacking the summary statistics named in the data_variable function type. The available ilike functions are detailed in the following sections. 4.7.4.1 Synthetic likelihood ilike::sl Specifies a synthetic likelihood (SL), as described in Wood (2010) and Price et al. (2018). The synthetic likelihood \\(l(s_{\\mbox{obs}} \\mid \\theta)\\) is given by \\[ l(s_{\\mbox{obs}} \\mid \\theta) = \\mathcal{MVN}\\left( s_{\\mbox{obs}} \\mid \\hat{\\mu}, \\hat{\\Sigma} \\right), \\tag{4.3} \\] where \\[ \\hat{\\mu} = \\frac{1}{M} \\sum_{j=1}^M s^{j} \\qquad \\hat{\\Sigma} = \\frac{1}{M-1} \\sum_{j=1}^M \\left( s^{j} - \\hat{\\mu} \\right) \\left( s^{j} - \\hat{\\mu} \\right)^T. \\tag{4.4} \\] Price et al. (2018) describes an extended version of this approach, which uses an unbiased estimate of the Gaussian distribution in equation (4.3), also based on \\(\\hat{\\mu}\\) and \\(\\hat{\\Sigma}\\) from equation (4.4). Inputs: integer: the number of simulations \\(M\\) to use in the synthetic likelihood (optional) boolean: whether to use the unbiased version of synthetic likelihood described in Price et al. (2018) (default is false) (optional) boolean: whether to store the output of the model simulations (default is false) (optional) boolean: whether to run the simulations in parallel (default is false) (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) 4.7.4.2 ABC (uniform kernel; Euclidean distance) ilike::euclidean_uniform_abc Specifies an approximate Bayesian computation (ABC), using a uniform kernel and Euclidean distance metric, as described in Sisson, Fan, and Beaumont (2018). The euclidean_uniform_abc likelihood \\(l(s_{\\mbox{obs}} \\mid \\theta)\\) is given, for tolerance level \\(\\epsilon\\), by \\[ l(s_{\\mbox{obs}} \\mid \\theta) = \\frac{1}{M}\\sum_{j=1}^{M}K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) \\] where \\[ K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) = \\begin{cases} 1/c &amp; \\text{if } d( s_{\\mbox{obs}} - s^{j} ) \\leq \\epsilon \\\\ 0 &amp; \\text{otherwise} \\end{cases}, \\] for \\[ c = \\frac{2^{d_s}\\Gamma\\left(\\frac{1}{2}+1\\right)^{d_s}}{\\Gamma\\left(\\frac{d_s}{2}+1\\right)}\\epsilon^{d_s}\\sum_{i=1}^{d_s}\\sigma_{i} \\] where \\[ d(s_{\\text{obs}},s)=\\left(\\sum_{i=1}^{d_{s}}\\left(\\frac{s_{\\text{obs},i}-s_{i}}{\\sigma_{i}}\\right)^{2}\\right)^{1/2} \\] Here \\(\\sigma_i\\) is a scaling used for the \\(i\\)th dimension of \\(s\\). The value of \\(c\\) is here to ensure that the uniform kernel is normalised, and uses the formula for volume of a \\(d_s\\)-dimensional ball. Inputs: integer: the number of simulations \\(M\\) to use in the ABC string: the name of the tolerance variable in the ABC numeric: the tolerance level for the ABC (optional) boolean: whether to store the output of the model simulations (default is false) (optional) string: the name of the variable that stores the scaling \\(\\sigma_i\\) of the data/summaries in the ABC (default is \"\" - in this case the scale will be 1 for every dimension) (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 5) is set. (optional) boolean: whether to run the simulations in parallel (default is false) (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) 4.7.4.3 ABC (uniform kernel; \\(L^p\\) distance) ilike::lp_uniform_abc Specified an approximate Bayesian computation (ABC) likelihood, using a uniform kernel and the \\(L^p\\) distance metric. The lp_uniform_abc likelihood \\(l(y \\mid \\theta)\\) is given, for tolerance level \\(\\epsilon\\), by \\[ l(s_{\\mbox{obs}} \\mid \\theta) = \\frac{1}{M}\\sum_{j=1}^{M}K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) \\] where \\[ K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) = \\begin{cases} 1/c &amp; \\text{if } d( s_{\\mbox{obs}} - s^{j} ) \\leq \\epsilon \\\\ 0 &amp; \\text{otherwise} \\end{cases}, \\] for \\[ c = \\frac{2^{d_s}\\Gamma\\left(\\frac{1}{p}+1\\right)^{d_s}}{\\Gamma\\left(\\frac{d_s}{p}+1\\right)}\\epsilon^{d_s}\\sum_{j=1}^{d_s}\\sigma_{i} \\] where \\[ d(s_{\\text{obs}},s)=\\left(\\sum_{i=1}^{d_{s}}\\left(\\frac{s_{\\text{obs},i}-s_{i}}{\\sigma_{i}}\\right)^{p}\\right)^{1/p} \\] Here \\(\\sigma_i\\) is a scaling used for the \\(i\\)th dimension of \\(s\\). The value of \\(c\\) is here to ensure that the uniform kernel is normalised, and uses the formula for volume of a \\(d_s\\)-dimensional ball in \\(L^p\\) space. Inputs: integer: the number of simulations \\(M\\) to use in the ABC string: the name of the tolerance variable in the ABC numeric: the tolerance level for the ABC numeric: the value of \\(p\\) for the \\(L^p\\) distance metric (optional) boolean: whether to store the output of the model simulations (default is false) (optional) string: the name of the variable that stores the scaling \\(\\sigma_i\\) of the data/summaries in the ABC (default is \"\" - in this case the scale will be 1 for every dimension) (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 6) is set. (optional) boolean: whether to run the simulations in parallel (default is false) (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) 4.7.4.4 ABC (Gaussian kernel) ilike::gaussian_abc Specifies an approximate Bayesian computation (ABC) likelihood, using a Gaussian kernel. The gaussian_abc likelihood \\(l(s_{\\mbox{obs}} \\mid \\theta)\\) is given, for tolerance level \\(\\epsilon\\), by \\[ l(s_{\\mbox{obs}} \\mid \\theta) = \\frac{1}{M}\\sum_{j=1}^{M}K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) \\] where \\[ K_{\\epsilon}\\left(s_{\\text{obs}}\\mid s^{j}\\right) = \\left(2\\pi\\epsilon\\right)^{-d_{y}/2}\\prod_{i=1}^{d_{s}}\\frac{1}{\\sigma_{i}^{2}}\\exp\\left(-\\frac{1}{2\\epsilon^{2}}\\sum_{i=1}^{d_{s}}\\left(\\frac{s_{\\text{obs},i}-s_{i}}{\\sigma_{i}}\\right)^{2}\\right). \\] Here \\(\\sigma_i\\) is a scaling used for the \\(i\\)th dimension of \\(s\\). Inputs: integer: the number of simulations \\(M\\) to use in the ABC string: the name of the tolerance variable in the ABC numeric: the tolerance level for the ABC (optional) boolean: whether to store the output of the model simulations (default is false) (optional) string: the name of the variable that stores the scaling \\(\\sigma_i\\) of the data/summaries in the ABC (default is \"\" - in this case the scale will be 1 for every dimension) (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 5) is set. (optional) boolean: whether to run the simulations in parallel (default is false) (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) 4.7.4.5 IEnKI-ABC ilike::ienki_abc Specifies an approximate Bayesian computation (ABC) likelihood, estimating using iterative ensemble Kalman inversion (IEnKI), as described in Everitt (2024). This approach uses an alternative estimator for the ABC likelihood using the Gaussian kernel, with tolerance \\(\\epsilon\\), described in section 4.7.4.4. IEnKI uses an ensemble of points to simulate from a sequence of \\(0:T\\) distributions using a decreasing sequence of tolerances \\(\\infty = \\epsilon_0 &gt; .... &gt; \\epsilon_T = \\epsilon\\). The 0th distrbution is \\(f_s( s \\mid \\theta)\\) (corresponding to the case where \\(\\epsilon=\\infty\\)), where \\(f_s\\) is the distribution resulting from the data generating process \\(f( \\cdot \\mid \\theta)\\) and the summary statistic transformation. The \\(t\\)th distribution for \\(t&gt;0\\) is \\(f_s( s \\mid \\theta) K_{\\epsilon_t}\\left(s_{\\text{obs}}\\mid s\\right)\\). The estimator of the normalising constant of the final target distribution, constructed using the ensemble at each step of the IEnKI, is an estimator of the ABC likelihood. This estimator is biased in general, but is likely to have significantly lower variance than that from standard ABC. When the final \\(\\epsilon\\) is taken to be zero, and \\(T=1\\), the estimator is the same as that used in synthetic likelihood (section 4.7.4.1). Full details can be found in Everitt (2024). Inputs: integer: the number of ensemble members \\(M\\) to use in the IEnKI-ABC integer: the estimator type constructed from the IEnKI output. The meaning of each of the four options below is given in the paper Everitt (2024). The options are: 1 (recommended): the “direct” estimator 2: the “unbiased” estimator, using the approach analogous to the unbiased method in Price et al. (2018) 3: the path sampling estimator 4: the alternative path sampling estimator from Friel, Hurn, and Wyse (2014) string: the name of the tolerance variable in the ABC numeric: the tolerance level for the ABC string: the shifter used in the IEnKI (the method for moving the ensemble at each iteration). The options are: stochastic (recommended): the stochastic shifter sqrt: the square root shifter adjustment: the adjustment shifter integer: the number of targets \\(T\\) used in the IEnKI (optional) numeric: the significance level for the significance test used in determining when to use the target skipping approach proposed in Everitt (2024) (default is 1, which results in skipping no targets; 0.1 recommended when using the stochastic shifter) (optional) integer: the number of iterations of output of each run of the IEnKI to store, counting from the final iteration backwards (default is 0) (optional) string: the name of the variable that stores the scaling \\(\\sigma_i\\) of the data/summaries in the ABC (default is \"\" - in this case the scale will be 1 for every dimension) (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 5) is set. (optional) boolean: whether to perform the IEnKI on the summary statistic space (default is true; false is largely untested) (optional) boolean: whether to run the simulations in parallel (default is false) (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) References Everitt, Richard G. 2024. “Ensemble Kalman Inversion Approximate Bayesian Computation.” arXiv Preprint arXiv:2407.18721. Friel, Nial, Merrilee Hurn, and Jason Wyse. 2014. “Improving Power Posterior Estimation of Statistical Evidence.” Statistics and Computing 24: 709–23. Price, Leah F, Christopher C Drovandi, Anthony Lee, and David J Nott. 2018. “Bayesian Synthetic Likelihood.” Journal of Computational and Graphical Statistics 27 (1): 1–11. Sisson, Scott A, Yanan Fan, and Mark Beaumont. 2018. Handbook of Approximate Bayesian Computation. CRC press. Wood, Simon N. 2010. “Statistical Inference for Noisy Nonlinear Ecological Dynamic Systems.” Nature 466 (7310): 1102–4. "],["algorithmic-likelihood.html", "4.8 Algorithmic likelihood", " 4.8 Algorithmic likelihood For some models, the likelihood can be computed or estimated by running an algorithm. For example, the marginal likelihood of a state-space model may be estimated using a particle filter. To specify such a likelihood, the user must provide a function type algorithmic_likelihood, then use an ilike function to specify the type of likelihood. 4.8.1 algorithmic_likelihood The likelihood function type allows the user to specify the likelihood through an ilike function. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted. The available ilike functions are detailed in the following sections. 4.8.1.1 Kalman filter ilike::kf The Kalman filter (KF) is a recursive algorithm that estimates the state of a linear Gaussian state-space model and, in this context, can be used to calculate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running a KF from the ilike R package as described in section ??. Inputs: string: The name of an ilike file (with extension) that contains the specification of a linear-Gaussian state-space model, as described in section 7. A full description of what is required in the file is given in section 2.6. (optional) integer: The number of iterations output of the KF to store, counting from the final iteration backwards (default is 0) 4.8.1.2 Particle filter ilike::pf The particle filter is a recursive algorithm that estimates the state of a general state-space model and, in this context, can be used to estimate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running a PF from the ilike R package as described in section 2.7. Inputs: string: The name of an ilike file (with extension) that contains the specification of a general state-space model, as described in section 7. A full description of what is required in the file is given in section 2.7. integer: The number of particles to use in the particle filter. (optional) integer: The number of iterations output of the PF to store, counting from the final iteration backwards (default is 0). (optional) boolean: Whether to run the particle filter in parallel (default is false). (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) 4.8.1.3 Ensemble Kalman filter ilike::enkf The ensemble Kalman filter (EnKF) is a recursive algorithm that estimates the state of a general state-space model and, in this context, can be used to estimate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running an EnKF from the ilike R package as described in section 2.8. Inputs: string: The name of an ilike file (with extension) that contains the specification of a general state-space model, as described in section 7. A full description of what is required in the file is given in section 2.8. integer: The number of ensemble members to use in the EnKF. string: The name of the shifter to use in the EnKF (the method for moving the ensemble at each iteration). The options are: stochastic: the stochastic shifter sqrt: the square root shifter adjustment: the adjustment shifter (optional) integer: The number of iterations output of the EnKF to store, counting from the final iteration backwards (default is 0). (optional) boolean: Whether to run the EnKF in parallel (default is false). (optional) integer: the grain size for parallelisation (default is 100000; see guidance here) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
