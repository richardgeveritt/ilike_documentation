[["mcmc.html", "Chapter 4 Markov chain Monte Carlo", " Chapter 4 Markov chain Monte Carlo When a Markov chain Monte Carlo (MCMC) is used for inference, most of the configuration of the algorithm must be done through the ilike file. ilike currently supports four different types of MCMC updates: Metropolis updates, which require the use of symmetric proposal distribution; Independent Metropolis-Hastings updates, which require a proposal distribution that is independent of the current state of the Markov chain; Metropolis-Hastings updates, which require a proposal distribution (which need not be symmetric and can be dependent on the current state of the Markov chain); Unadjusted updates, which use only the specified proposal distribution to generate new states, i.e. there is no Metropolis-Hastings correction. Each of these types of updates require the specification of a proposal, and each type of update is specified by using different function types for the proposal: e.g. using the function type mh_proposal will result in using this proposal in a Metropolis-Hastings algorithm. Before describing the different types of proposals, we describe how to provide the compiler with the following details: The means by which the MCMC will be terminated (e.g. the number of iterations); How to compose the MCMC updates, via deterministic or stochastic sweeps; How to determine which factors are involved in the Metropolis-Hastings acceptance ratio. "],["mcmc-termination.html", "4.1 MCMC termination", " 4.1 MCMC termination The most common way to terminate a run of MCMC is after a pre-determined number of iterations. This is currently the only approach supported by ilike, and is set via the function type mcmc_termination. 4.1.1 mcmc_termination "],["mcmc-sweeps.html", "4.2 MCMC sweeps", " 4.2 MCMC sweeps ilike can compose the available MCMC updates into either a deterministic or a stochastic sweep. A deterministic sweep will use each type of update in turn, in the order in which the updates are provided in the ilike file. The updates will instead be chosen at random if the user provides the function type mcmc_weights1. 4.2.1 mcmc_weights This function type allows the user to specify the probability of each type of update being used in the MCMC algorithm. The vector of probabilities need not be normalised, and the order of the vector must correspond to the order in which the proposals are provided in the ilike file. There are no inputs. Output: The probability of choosing each type of update. – of type std::vector&lt;double&gt; in a C++ function – available as R numeric vector in an R function ilike uses no representation of the conditional independence structure of the joint distribution, therefore it is unable to automatically recognise when some factors in the joint distribution need not be evaluated in a Metropolis or Metropolis-Hastings update. To avoid evaluating every factor, the user can provide an mh_factor_index (or, depending on the type of proposal, m_factor_index, etc) function type following the proposal function type, referring to the factors that should be included in the Metropolis-Hastings acceptance ratio. When this function type is not provided, all factors will be evaluated in the acceptance ratio. Note that this results in one update being used per MCMC iteration, whereas the deterministic sweep will use every update in a sweep. Therefore when using the stochastic approach, one should use \\(L\\) times the number of MCMC iterations, if there are \\(L\\) updates provided.↩︎ "],["user-defined-mh-proposals.html", "4.3 User-defined MH proposals", " 4.3 User-defined MH proposals The functions in this section allow the specification of a user-defined Metropolis-Hastings (MH) proposal. If a proposal is provided, and a Markov chain Monte Carlo (MCMC) or sequential Monte Carlo inference algorithm is used, a Metropolis-Hastings algorithm will be used for the MCMC moves in the algorithm. A custom MH proposal requires the specification of two function types: simulate_mh_proposal and evaluate_log_mh_proposal. 4.3.1 simulate_mh_proposal The simulate_mh_proposal function type simulates an MH proposal distribution. There are two optional arguments for this function type, allowing the proposal to depend on some parameters, or the observed data. The arguments that are chosen must be specified in the order of the inputs listed below. Input: (C++ only) The random number generator. – of type RandomNumberGenerator &amp; in a C++ function Input: The current state of the MCMC chain. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Input: (optional) Any parameters the proposal relies on. – of type const Parameters &amp; in a C++ function – available as R list proposal_parameters in an R function Input: (optional) Any data the proposal relies on. – of type const Data &amp; in a C++ function – available as R list data in an R function Output: The proposed parameters. – of type const Parameters &amp; in a C++ function – of type list in R C++ example: /***simulate_mh_proposal***/ Parameters simulate_proposal(RandomNumberGenerator &amp;rng, const Parameters &amp;parameters, const Parameters &amp;proposal_parameters) { arma::colvec x(1,1); x[0] = rnorm(rng, parameters[&quot;x&quot;][0], proposal_parameters[&quot;theta&quot;][0]]); return Parameters(&quot;x&quot;, x); } R example: /***simulate_mh_proposal,x=rnorm(1,parameters$x,proposal_parameters$theta)***/ 4.3.2 evaluate_log_mh_proposal The evaluate_log_mh_proposal function type evaluates the log density of the MH proposal distribution. As for simulate_mh_proposal, there are two optional arguments for this function type, allowing the proposal to depend on some parameters, or the observed data. The arguments that are chosen must be specified in the order of the inputs listed below. Input: The proposed parameters. – of type const Parameters &amp; in a C++ function – available as R list proposed_parameters in an R function Input: The current state of the MCMC chain. – of type const Parameters &amp; in a C++ function – available as R list parameters in an R function Input: (optional) Any parameters the proposal relies on. – of type const Parameters &amp; in a C++ function – available as R list proposal_parameters in an R function Input: (optional) Any data the proposal relies on. – of type const Data &amp; in a C++ function – available as R list data in an R function Output: The log density of the proposed parameters under the proposal distribution. – of type double in a C++ function – of type numeric in R C++ example: /***evaluate_log_mh_proposal***/ double log_mh_density(const Parameters &amp;proposed_parameters, const Parameters &amp;parameters, const Parameters &amp;proposal_parameters) { double proposed_x = proposed_parameters[&quot;x&quot;][0]; double current_x = parameters[&quot;x&quot;][0]; double theta = proposal_parameters[&quot;theta&quot;][0]; return dnorm(proposed_x, current_x, theta); } R example: /***evaluate_log_mh_proposal,dnorm(proposed_parameters$x,parameters$x,proposal_parameters$theta,log=TRUE)***/ "],["mh-proposal-ilike.html", "4.4 MH proposal: ilike", " 4.4 MH proposal: ilike 4.4.1 mh_proposal (ilike functions) The mh_proposal function type allows the user to specify a Metropolis-Hastings proposal through an ilike function. If a proposal is provided, and a Markov chain Monte Carlo (MCMC) or sequential Monte Carlo inference algorithm is used, a Metropolis-Hastings algorithm will be used for the MCMC moves in the algorithm. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted. The following sections detail the available ilike functions. 4.4.1.1 Normal random walk proposal ilike::norm_rw Specifies a normal random walk proposal over the given variable, where the proposed state \\(\\theta^*\\) is simulated using \\[ \\theta^* \\sim \\mathcal{N}(\\theta}, \\sigma) \\] Inputs: string: the variable for which the proposal is specified numeric: the standard deviation \\(\\sigma\\) of the normal distribution 4.4.1.2 Multivariate normal random walk proposal ilike::mvnorm_rw Specifies a multivariate random walk normal proposal over the given variable, where the proposed state \\(\\theta^*\\) is simulated using \\[ \\theta^* \\sim \\mathcal{MVN}(\\theta, s^2 \\Sigma) \\] Inputs: string: the variable for which the proposal is specified matrix: the covariance \\(\\Sigma\\) of the multivariate normal distribution numeric: the scaling factor \\(s^2\\) of the covariance matrix (default is 1) 4.4.1.3 Uniform random walk proposal ilike::unif_rw Specifies a uniform random walk proposal over the given variable, where the proposed state \\(\\theta^*\\) is simulated using \\[ \\theta^* \\sim \\mathcal{U}(\\theta - \\sigma, \\theta} + \\sigma) \\] Inputs: string: the variable for which the proposal is specified numeric: the half-width of the uniform distribution 4.4.1.4 Multivariate uniform random walk proposal ilike::mvunif_rw Specifies a multivariate random walk normal proposal over the given variable, where proposed state \\(\\theta^*\\) is simulated using \\[ \\theta^* \\sim \\mathcal{MVU}(\\theta - \\Sigma, \\theta + \\Sigma) \\] Inputs: string: the variable for which the proposal is specified vector/matrix: a matrix of half-widths of the uniform distribution, which must have the same dimensionality as \\(\\theta\\) 4.4.1.5 Langevin proposal ilike::langevin Specifies a Langevin proposal over the given variable, where the proposed state \\(\\theta^*\\) is simulated using \\[ \\theta^* \\sim \\mathcal{MVN}(\\theta + \\frac{s^2}{2} \\Sigma \\nabla \\log \\pi(\\theta), s^2 \\Sigma) \\] The presence of \\(\\nabla \\log \\pi(\\theta)\\) in the proposal requires that the gradient of the log of each factor must be available. \\(s^2\\) is scaling factor for the preconditioning matrix \\(\\Sigma\\). Inputs: string: the variable for which the proposal is specified matrix: the covariance \\(\\Sigma\\) of the multivariate normal distribution used in the proposal numeric: the scaling factor \\(s^2\\) of the preconditioning matrix (default is 1) 4.4.1.6 Barker proposal ilike::barker Specifies a Barker proposal over the given variable, as described in Livingstone and Zanella (2022), where the proposed state \\(\\theta^*\\) is simulated using the following procedure. For the following, let: \\(d\\) be the dimension of \\(\\theta\\), \\(\\mathbf{0}_d\\) be the zero vector in \\(\\mathbb{R}\\); \\(\\mathbf{I}_d\\) be the identity covariance matrix in \\(\\mathbb{R}^{d\\times d}\\); and let \\(\\odot\\) be the Hadamard (element-wise) product. Let \\(C = \\mbox{chol}(s^2 \\Sigma)\\), then \\[ z \\sim \\mathcal{MNV}(\\mathbf{0}_d, \\mathbf{I}_d) \\] followed by, for \\(i=1:d\\) \\[ u_i\\sim \\mathcal{U}(0,1) \\] \\[ c_i(\\theta) = \\nabla \\log \\pi(\\theta) C^T \\] \\[ b_i = -1 + 2 \\times I \\left( u_i &lt; 1/(1 + \\exp(-z_i c_i(\\theta) )) \\right) \\] \\[ \\theta^* = \\theta + b \\odot z \\] The presence of \\(\\nabla \\log \\pi(\\theta)\\) in the proposal requires that the gradient of the log of each factor must be available. \\(s^2\\) is scaling factor for the preconditioning matrix \\(\\Sigma\\). Inputs: string: the variable for which the proposal is specified matrix: the covariance \\(\\Sigma\\) of the multivariate normal distribution used in the proposal numeric: the scaling factor \\(s^2\\) of the preconditioning matrix (default is 1) 4.4.1.7 Mirror proposal ilike::mirror Specifies a mirror proposal over the given variable, as described in Thawornwattana, Dalquen, and Yang (2018), where the proposed state \\(\\theta^*\\) is simulated using \\[ \\theta^* \\sim \\mathcal{MVN} (2 \\mu - \\theta, s^2 \\Sigma), \\] where \\(\\mu\\) is a centre (typically an estimate of the expectation of the target distribution) and \\(s^2\\) is scaling factor for the covariance matrix \\(\\Sigma\\). Inputs: string: the variable for which the proposal is specified numeric: the centre \\(\\mu\\) of the mirror proposal matrix: the covariance \\(\\Sigma\\) of the multivariate normal distribution used in the proposal numeric: the scaling factor \\(s^2\\) of the covariance matrix (default is 1) prior_function_types = c(&quot;prior&quot;,&quot;evaluate_log_prior&quot;,&quot;simulate_prior&quot;,&quot;evaluate_gradient_log_prior&quot;,&quot;evaluate_second_gradient_log_prior&quot;) custom_likelihood_function_types = c(&quot;evaluate_log_likelihood&quot;,&quot;evaluate_gradient_log_likelihood&quot;,&quot;evaluate_second_gradient_log_likelihood&quot;) #file_likelihood_types = c(&quot;importance_sample&quot;,&quot;smc_mcmc_move&quot;) sbi_likelihood_function_types = c(&quot;simulate_data_model&quot;,&quot;sbi_likelihood&quot;,&quot;summary_statistics&quot;,&quot;data_variable&quot;) linear_gaussian_data_model_types = c(&quot;linear_gaussian_data_model&quot;,&quot;linear_gaussian_data_matrix&quot;,&quot;linear_gaussian_data_covariance&quot;,&quot;linear_gaussian_data_variable&quot;,&quot;linear_gaussian_data_state_variable&quot;) nonlinear_gaussian_data_model_types = c(&quot;nonlinear_gaussian_data_model&quot;,&quot;nonlinear_gaussian_data_function&quot;,&quot;nonlinear_gaussian_data_covariance&quot;,&quot;nonlinear_gaussian_data_variable&quot;) other_likelihood_function_types = c(&quot;likelihood&quot;) factor_function_types = c(prior_function_types,custom_likelihood_function_types,sbi_likelihood_function_types,linear_gaussian_data_model_types,nonlinear_gaussian_data_model_types,other_likelihood_function_types) ilike_transition_model_types = c(&quot;transition_model&quot;) linear_gaussian_transition_model_types = c(&quot;linear_gaussian_transition_model&quot;,&quot;linear_gaussian_transition_matrix&quot;,&quot;linear_gaussian_transition_covariance&quot;,&quot;linear_gaussian_transition_variable&quot;) nonlinear_gaussian_transition_model_types = c(&quot;nonlinear_gaussian_transition_model&quot;,&quot;nonlinear_gaussian_transition_function&quot;,&quot;nonlinear_gaussian_transition_covariance&quot;,&quot;nonlinear_gaussian_transition_variable&quot;) custom_transition_model_types = c(&quot;simulate_transition_model&quot;,&quot;evaluate_log_transition_model&quot;) transition_model_types = c(ilike_transition_model_types,linear_gaussian_transition_model_types,nonlinear_gaussian_transition_model_types,custom_transition_model_types) custom_potential_function_types = c(&quot;evaluate_log_potential_function&quot;) ilike_potential_function_types = c(&quot;potential_function&quot;) potential_function_types = c(custom_potential_function_types,ilike_potential_function_types) data_function_types = c(&quot;data&quot;) importance_proposal_types = c(&quot;simulate_importance_proposal&quot;,&quot;evaluate_log_importance_proposal&quot;,&quot;importance_proposal&quot;) mh_proposal_types = c(&quot;simulate_mh_proposal&quot;,&quot;evaluate_log_mh_proposal&quot;,&quot;mh_proposal&quot;,&quot;mh_transform&quot;,&quot;mh_inverse_transform&quot;,&quot;mh_transform_jacobian_matrix&quot;,&quot;mh_factor_index&quot;) unadjusted_proposal_types = c(&quot;simulate_unadjusted_proposal&quot;,&quot;unadjusted_proposal&quot;,&quot;unadjusted_transform&quot;,&quot;unadjusted_inverse_transform&quot;,&quot;unadjusted_transform_jacobian_matrix&quot;,&quot;unadjusted_factor_index&quot;) independent_mh_proposal_types = c(&quot;simulate_independent_mh_proposal&quot;,&quot;evaluate_log_independent_mh_proposal&quot;,&quot;independent_mh_proposal&quot;,&quot;independent_mh_transform&quot;,&quot;independent_mh_inverse_transform&quot;,&quot;independent_mh_transform_jacobian_matrix&quot;,&quot;independent_mh_factor_index&quot;) m_proposal_types = c(&quot;simulate_m_proposal&quot;,&quot;m_proposal&quot;,&quot;m_transform&quot;,&quot;m_inverse_transform&quot;,&quot;m_transform_jacobian_matrix&quot;,&quot;m_factor_index&quot;) transition_proposal_types = c(&quot;simulate_transition_proposal&quot;,&quot;evaluate_log_transition_proposal&quot;) enk_transform_types = c(&quot;enk_transform&quot;,&quot;enk_inverse_transform&quot;) #reinforce_gradient = c(&quot;reinforce_gradient&quot;) method_function_types = c(&quot;mcmc_weights&quot;,&quot;mcmc_termination&quot;,&quot;adaptive_resampling&quot;,&quot;adaptive_target&quot;,&quot;smc_termination&quot;,&quot;smc_sequence&quot;,&quot;reinforce_gradient&quot;,&quot;enk_likelihood_index&quot;,&quot;enk_shifter&quot;,&quot;filter&quot;) References Livingstone, Samuel, and Giacomo Zanella. 2022. “The Barker Proposal: Combining Robustness and Efficiency in Gradient-Based MCMC.” Journal of the Royal Statistical Society Series B: Statistical Methodology 84 (2): 496–523. Thawornwattana, Yuttapong, Daniel Dalquen, and Ziheng Yang. 2018. “Designing Simple and Efficient Markov Chain Monte Carlo Proposal Kernels.” "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
