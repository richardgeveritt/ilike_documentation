# ilike blocks {#blocks}

This section details all block types (e.g. "factor") and subtypes (e.g. "prior"), and all function types (e.g. "evaluate_log_prior") available in ilike. Each subsection is devoted to a particular block type, with subsubsections being devoted to each function type. Each subsubsection details the input and output arguments of the function, and gives an example of its use. The specification of each function type is described in both C++ and R. Python and Julia function are both called from R - see section \@ref(ilike-files) - so do not require further description).

The available block types, with subtypes, are as follows:

- **factor**. Factors of a joint distribution.

  -- **prior**
  
  -- **exact likelihood**
  
  -- **simulation-based likelihood**
  
  -- **linear gaussian**
  
  -- **non-linear Gaussian**

- **importance sampling proposal**. An importance sampling proposal.

  -- **exact**
  
- **Metropolis proposal**. A proposal for a Metropolis algorithm.

  -- **exact**
  
- **Metropolis-Hastings proposal**. A proposal for a Metropolis-Hastings algorithm.

  -- **exact**
  
- **independent Metropolis-Hastings proposal**. An independent proposal for a Metropolis-Hastings algorithm.

  -- **exact**
  
- **unadjusted proposal**. A proposal used for MCMC moves without a Metropolis-Hastings acceptance correction.

  -- **exact**
  
- **transition model**. The transition model in a state-space model.

  -- **exact**
  
  -- **linear Gaussian**
  
  -- **non-linear Gaussian**
  
- **transition proposal**. The transition proposal for a particle filter.

  -- **exact**
  
  -- **linear Gaussian**
  
  -- **non-linear Gaussian**

- **data**. Observed data. (no subtypes)

- **method**. Used to specify parameters for inference algorithms.  (no subtypes)

Recall, from \@ref(file-structure), that the block type (and subtype) are determined by function types in the block. The block type (or subtype) does not need to be specified in the ilike file. We include these terms for the purposes of organising the documentation, and to help a user understand the output generated by compiling the ilike file should they wish to.

## Factor blocks

### Prior

There are two ways of specifying priors:

1. Through some combination of function types (e.g. `evaluate_log_prior`, `simulate_prior`) defined below. The user only needs to specify the function types required by the algorithm they wish to use. For example:

  -- `evaluate_log_prior` for Metropolis-Hastings where the prior needs to be evaluated in the acceptance ratio;
  
  -- `simulate_prior` for importance sampling where the prior is used as the proposal, and the prior cancels and does not need to be evaluated in the weight update;
  
  -- `evaluate_gradient_log_prior` for an unadjusted Langevin MCMC which requires the gradient of the prior to make moves.
  
2. Through the function type `prior`, which allows the user to specify the prior through an ilike function (e.g. `ilike::norm`), which results in the specification of all of the other prior function types (i.e. `evaluate_log_prior`, `simulate_prior`, `evaluate_gradient_log_prior` and `evaluate_second_gradient_log_prior` are all specified by using `ilike::norm`).

We now detail the function types available for specifying a prior.

#### evaluate_log_prior

The `evaluate_log_prior` function type calculates the log prior density of the parameters.

Input: The point at which the log of the prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function

Output: The log prior density of the parameters.

  -- of type `double` in a C++ function
  
  -- of type `numeric` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_log_prior***/
double prior_eval(const Parameters &parameters)
{
  return dnorm(parameters["θ"][0]);
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_log_prior,dnorm(parameters$θ)***/
```

#### simulate_prior

The `simulate_prior` function type samples from the prior distribution.

Input: (C++ only) The random number generator.

  -- of type `RandomNumberGenerator &` in a C++ function

Output: The simulated value.

  -- of class `Parameters` in a C++ function
  
  -- an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an `=` sign in the function header.
  
C++ example:

```{Rcpp,eval=FALSE}
/***simulate_prior***/
Parameters prior_sim(RandomNumberGenerator &rng)
{
  return Parameters("θ",rnorm(rng));
}
```

R example:

```{Rcpp,eval=FALSE}
/***simulate_prior,θ=rnorm(1)***/
```

#### evaluate_gradient_log_prior

The `evaluate_gradient_log_prior` function type gives the differential of the log prior density of the parameters.

Input: The variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable` in an R function

Input: The point at which the gradient of the log prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The gradient of the log prior density of the parameters.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_prior***/
arma::mat prior_gradient_eval(const std::string &variable,
                              const Parameters &parameters)
{
  if (variable=="θ")
  {
    arma::mat grad(1,1);
    grad(0,0) = -parameters["θ"][0];
    return grad;
  }
  else
  {
    Rcpp::stop("Unknown variable in prior gradient.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_prior,if (variable=="θ") {-parameters$θ} else {stop("Unknown variable in prior gradient.")}***/
```

#### evaluate_second_gradient_log_prior

The `evaluate_gradient_log_prior` function type gives the second differential of the log prior density of the parameters.

Input: The first variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable1` in an R function
  
Input: The second variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable2` in an R function

Input: The point at which the gradient of the log prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The Hessian of the log prior density, evaluated at the given point.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_prior***/
arma::mat prior_gradient_eval(const std::string &variable1,
                              const std::string &variable2,
                              const Parameters &parameters)
{
  if ((variable1=="θ") && (variable2=="θ"))
  {
    arma::mat grad(1,1);
    grad(0,0) = -1.0;
    return grad;
  }
  else
  {
    Rcpp::stop("Unknown variable in prior second gradient.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_prior,if ((variable1=="θ") && (variable2=="θ")) {-1} else {stop("Unknown variable in prior second gradient.")}***/
```

#### prior

The `prior` function type allows the user to specify the prior through an ilike function (e.g. `ilike::norm`), which results in the specification of all of the other prior function types. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order.

Example of the use of one of these functions (`ilike::norm`) follows.

```{Rcpp,eval=FALSE}
/***prior,ilike::norm(θ,0,1)***/
```

The following ilike functions are available:

- `ilike::norm`: a normal prior. Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric: the mean of the normal distribution
    
  3. numeric: the standard deviation of the normal distribution
    
- `ilike::mvnorm`: a multivariate normal prior. Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric vector/matrix: the mean of the multivariate normal distribution
    
  3. matrix: the covariance of the multivariate normal distribution
    
- `ilike::lnorm`: a lognormal prior. Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric: the mean of the log of the variable
    
  3. numeric: the standard deviation of the log of the variable
    
- `ilike::mvnorm`: a multivariate loggnormal prior. Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric vector/matrix: the mean of the log of the variable
    
  3. matrix: the covariance of the log of the variable
    
- `ilike::gamma`: a gamma prior. Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric: the shape of the gamma distribution
    
  3. numeric: the rate of the gamma distribution

### Exact likelihood

The functions in this section allow the specification of a user-defined likelihood. Only the functions required by the chosen inference algorithm need be specified.

Usually we recommend specifying, rather than a likelihood, the data model. This will ensure that, when running importance sampling for example, the normalising constant estimate returned by that algorithm will be an estimate of the marginal likelihood. However, where the goal is simulating from or approximating the posterior distribution, specifying the model up to proportionality is sufficient.

#### evaluate_log_likelihood

The `evaluate_log_likelihood` function type calculates the log likelihood of the parameters.

Input: The point at which the log likelihood is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
 Input: The observed data for which the log likelihood is to be evaluated.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function

Output: The log likelihood of the parameters using the observed data.

  -- of type `double` in a C++ function
  
  -- of type `numeric` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_log_likelihood***/
double likelihood_eval(const Parameters &parameters,
                       const Data &data)
{
  double y = data["y"];
  return sum(dnorm(y,parameters["θ"][0],1.0));
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_log_likelihood,sum(dnorm(data$y,parameters$θ,1.0))***/
```

#### evaluate_gradient_log_likelihood

The `evaluate_gradient_log_likelihood` function type calculates the gradient of the log likelihood of the parameters.

Input: The variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable` in an R function
  
Input: The point at which the gradient of the log likelihood is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Input: The observed data for which the gradient of the log likelihood is to be evaluated.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function

Output: The gradient of the log likelihood of the parameters.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_likelihood***/
arma::mat likelihood_gradient_eval(const std::string &variable,
                                   const Parameters &parameters,
                                   const Data &data)
{
  if (variable=="θ")
  {
    arma::colvec y = data["y"];
    arma::mat grad(1,1);
    grad(0,0) = arma::sum((y-parameters["θ"][0])/1.0);
    return grad;
  }
  else
  {
    Rcpp::stop("Unknown variable in likelihood gradient.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_likelihood,if (variable=="θ") {sum((data$y-parameters$θ)/1.0)} else {stop("Unknown variable in likelihood gradient.")}***/
```

#### evaluate_second_gradient_log_likelihood

The `evaluate_gradient_log_prior` function type gives the second differential of the log likelihood of the parameters.

Input: The first variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable1` in an R function
  
Input: The second variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable2` in an R function
  
Input: The point at which the gradient of the log prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The Hessian of the log likelihood, evaluated at the given point.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R.

C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_likelihood***/
arma::mat likelihood_hessian_eval(const std::string &variable1,
                                  const std::string &variable2,
                                  const Parameters &parameters,
                                  const Data &data)
{
  if (variable1=="θ" && variable2=="θ")
  {
    arma::mat hess(1,1);
    hess(0,0) = -data["y"].size()/1.0;
    return hess;
  }
  else
  {
    Rcpp::stop("Unknown variable in likelihood hessian.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_likelihood,if (variable1=="θ" && variable2=="θ") {-length(data$y)/1.0} else {stop("Unknown variable in likelihood hessian.")}***/
```

### Simulation-based likelihood

The functions in this section allow the specification of a likelihood through a function that simulates a data generating process, for example through approximate Bayesian computation. There are three function types that are required to be specified for all simulation-based likelihoods:

- `simulate_data_model`, which simulates the data generating process.

- `data_variable`, which specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation.

- `sbi_likelihood`, which uses an ilike function to define the desired simulation-based likelihood.

It is also possible to reduce the observed data to summary statistcs (though the use of the `summary_statistics` function type) for use in the simulation-based likelihood.

#### simulate_data_model

The `simulate_data_model` function type simulates the data generating process.

Input: (C++ only) The random number generator to be used in the simulation.

  -- of type `RandomNumberGenerator &` in a C++ function

Input: The parameters at which to simulate the data.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function

Output: The simulated data.

  -- of class `Data` in a C++ function
  
  -- an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an `=` sign in the function header.
  
C++ example:

```{Rcpp,eval=FALSE}
/***simulate_data_model***/
Data simulate_data_model(RandomNumberGenerator &rng,
                         const Parameters &parameters)
{
  arma::colvec y = rnorm(rng,100,parameters["θ"][0],1.0);
  return Data("y", y);
}
```

R example:

```{Rcpp,eval=FALSE}
/***simulate_data_model,y=rnorm(100,parameters$θ,1)***/
```

#### data_variable

The `data_variable` function type specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. There are no input arguments.

Output: The variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. To specify multiple output variables they must be separated by a semi-colon (with no spaces).

  -- of type `const std::string &` in a C++ function
  
  -- a string in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***data_variable***/
std::string a_variable()
{
  return "y"; // could be "y;z" for variables y and z
}
```

R example:

```{Rcpp,eval=FALSE}
/***data_variable,"y"***/
```

#### sbi_likelihood

The `sbi_likelihood` function type uses an ilike function to define the desired simulation-based likelihood. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted.

Example of the use of one of these functions (`ilike::sl`) follows.

```{Rcpp,eval=FALSE}
/***sbi_likelihood,ilike::sl(50)***/
```

The following ilike functions are available:

- `ilike::sl`: Synthetic likelihood, as described in @wood2010statistical and @price2018bayesian. Inputs:

  1. integer: the number simulations to use in the synthetic likelihood
  
  2. (optional) boolean: whether to use the unbiased version of synthetic likelihood described in @price2018bayesian (default is `false`)
  
  3. (optional) boolean: whether to store the output of the model simulations (default is `false`)
  
  4. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  5. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))
  
- `ilike::abc`: Approximate Bayesian computation, as described in @sisson2018handbook. Inputs:

  1. integer: the number simulations to use in the ABC
  
  2. string: the name of the tolerance variable in the ABC
  
  3. numeric: the tolerance level for the ABC
  
  4. (optional) string: the name of the variable that stores the scaling of the data/summaries in the ABC (default is `""` - in this case the scale will be `1` for every dimension)
  
  5. (optional) numeric vector: the scaling of the data/summaries in the ABC. If the scale variable (argument 4) is set, the scale will be estimated using the standard deviation of the simulations from the ABC, if not, or the number of ABC simulations (argument 1) is 1, the default is `1` for every dimension.
  
  6. (optional) boolean: whether to store the output of the model simulations (default is `false`)
  
  7. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  8. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))

## Data block

### Data

#### data

The `data` function type returns observed data. There are no input arguments.

Output: The observed data.

  -- of class `Data` in a C++ function
  
  -- an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an `=` sign in the function header.
  
C++ example:

```{Rcpp,eval=FALSE}
/***data***/
Data set_data()
{
  arma::colvec y(2,1);
  y[0] = 1.0;
  y[1] = 2.0;
  return Data("y", y);
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_log_prior,y=c(1,2)***/
```



```{r}
  prior_function_types = c("prior","evaluate_log_prior","simulate_prior","evaluate_gradient_log_prior","evaluate_second_gradient_log_prior")
  custom_likelihood_function_types = c("evaluate_log_likelihood","evaluate_gradient_log_likelihood","evaluate_second_gradient_log_likelihood")
  #file_likelihood_types = c("importance_sample","smc_mcmc_move")
  sbi_likelihood_function_types = c("simulate_data_model","sbi_likelihood","summary_statistics","data_variable")
  linear_gaussian_data_model_types = c("linear_gaussian_data_model","linear_gaussian_data_matrix","linear_gaussian_data_covariance","linear_gaussian_data_variable","linear_gaussian_data_state_variable")
  nonlinear_gaussian_data_model_types = c("nonlinear_gaussian_data_model","nonlinear_gaussian_data_function","nonlinear_gaussian_data_covariance","nonlinear_gaussian_data_variable")
  other_likelihood_function_types = c("likelihood")
  factor_function_types = c(prior_function_types,custom_likelihood_function_types,sbi_likelihood_function_types,linear_gaussian_data_model_types,nonlinear_gaussian_data_model_types,other_likelihood_function_types)
  ilike_transition_model_types = c("transition_model")
  linear_gaussian_transition_model_types = c("linear_gaussian_transition_model","linear_gaussian_transition_matrix","linear_gaussian_transition_covariance","linear_gaussian_transition_variable")
  nonlinear_gaussian_transition_model_types = c("nonlinear_gaussian_transition_model","nonlinear_gaussian_transition_function","nonlinear_gaussian_transition_covariance","nonlinear_gaussian_transition_variable")
  custom_transition_model_types = c("simulate_transition_model","evaluate_log_transition_model")
  transition_model_types = c(ilike_transition_model_types,linear_gaussian_transition_model_types,nonlinear_gaussian_transition_model_types,custom_transition_model_types)
  custom_potential_function_types = c("evaluate_log_potential_function")
  ilike_potential_function_types = c("potential_function")
  potential_function_types = c(custom_potential_function_types,ilike_potential_function_types)
  data_function_types = c("data")
  importance_proposal_types = c("simulate_importance_proposal","evaluate_log_importance_proposal","importance_proposal")
  mh_proposal_types = c("simulate_mh_proposal","evaluate_log_mh_proposal","mh_proposal","mh_transform","mh_inverse_transform","mh_transform_jacobian_matrix","mh_factor_index")
  unadjusted_proposal_types = c("simulate_unadjusted_proposal","unadjusted_proposal","unadjusted_transform","unadjusted_inverse_transform","unadjusted_transform_jacobian_matrix","unadjusted_factor_index")
  independent_mh_proposal_types = c("simulate_independent_mh_proposal","evaluate_log_independent_mh_proposal","independent_mh_proposal","independent_mh_transform","independent_mh_inverse_transform","independent_mh_transform_jacobian_matrix","independent_mh_factor_index")
  m_proposal_types = c("simulate_m_proposal","m_proposal","m_transform","m_inverse_transform","m_transform_jacobian_matrix","m_factor_index")
  transition_proposal_types = c("simulate_transition_proposal","evaluate_log_transition_proposal")
  enk_transform_types = c("enk_transform","enk_inverse_transform")
  #reinforce_gradient = c("reinforce_gradient")
  method_function_types = c("mcmc_weights","mcmc_termination","adaptive_resampling","adaptive_target","smc_termination","smc_sequence","reinforce_gradient","enk_likelihood_index","enk_shifter","filter")
```