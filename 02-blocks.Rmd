# ilike blocks {#blocks}

This section details all block types (e.g. "factor") and subtypes (e.g. "prior"), and all function types (e.g. "evaluate_log_prior") available in ilike. Each subsection is devoted to a particular block type (subtype), with subsections being devoted to each function type. Each subsection details the input and output arguments of the function, and gives an example of its use. The specification of each function type is described in both C++ and R. Python and Julia function are both called from R - see section \@ref(ilike-files) - so do not require further description).

The available block types, with subtypes, are as follows:

- **factor**. Factors of a joint distribution.

  -- **prior**
  
  -- **exact likelihood**
  
  -- **simulation-based likelihood**
  
  -- **linear gaussian data model**
  
  -- **non-linear Gaussian data model**

- **importance sampling proposal**. An importance sampling proposal.

  -- **exact**
  
- **Metropolis proposal**. A proposal for a Metropolis algorithm.

  -- **exact**
  
- **Metropolis-Hastings proposal**. A proposal for a Metropolis-Hastings algorithm.

  -- **exact**
  
- **independent Metropolis-Hastings proposal**. An independent proposal for a Metropolis-Hastings algorithm.

  -- **exact**
  
- **unadjusted proposal**. A proposal used for MCMC moves without a Metropolis-Hastings acceptance correction.

  -- **exact**
  
- **transition model**. The transition model in a state-space model.

  -- **exact**
  
  -- **linear Gaussian**
  
  -- **non-linear Gaussian**
  
- **transition proposal**. The transition proposal for a particle filter.

  -- **exact**
  
  -- **linear Gaussian**
  
  -- **non-linear Gaussian**

- **data**. Observed data. (no subtypes)

- **method**. Used to specify parameters for inference algorithms.  (no subtypes)

Recall, from \@ref(file-structure), that the block type (and subtype) are determined by function types in the block. The block type (or subtype) does not need to be specified in the ilike file. We include these terms for the purposes of organising the documentation, and to help a user understand the output generated by compiling the ilike file should they wish to.

## Factor: custom prior

There are two ways of specifying priors: (a) through the user supplying functions such as  `evaluate_log_prior`; (b) through the use of ilike functions giving pre-defined priors such as `ilike::norm`. This section describes (a), with (b) being described in section \@ref(ilike-prior).

A custom prior is specified through some combination of function types (e.g. `evaluate_log_prior`, `simulate_prior`). The user only needs to specify the function types required by the algorithm they wish to use. For example:

  -- `evaluate_log_prior` for Metropolis-Hastings where the prior needs to be evaluated in the acceptance ratio;
  
  -- `simulate_prior` for importance sampling where the prior is used as the proposal, and the prior cancels and does not need to be evaluated in the weight update;
  
  -- `evaluate_gradient_log_prior` for an unadjusted Langevin MCMC which requires the gradient of the prior to make moves.

We now describe the available function types.

### evaluate_log_prior

The `evaluate_log_prior` function type calculates the log prior density of the parameters.

Input: The point at which the log of the prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function

Output: The log prior density of the parameters.

  -- of type `double` in a C++ function
  
  -- of type `numeric` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_log_prior***/
double prior_eval(const Parameters &parameters)
{
  return dnorm(parameters["θ"][0]);
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_log_prior,dnorm(parameters$θ,log=TRUE)***/
```

### simulate_prior

The `simulate_prior` function type samples from the prior distribution.

Input: (C++ only) The random number generator.

  -- of type `RandomNumberGenerator &` in a C++ function

Output: The simulated value.

  -- of class `Parameters` in a C++ function
  
  -- an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an `=` sign in the function header.
  
C++ example:

```{Rcpp,eval=FALSE}
/***simulate_prior***/
Parameters prior_sim(RandomNumberGenerator &rng)
{
  return Parameters("θ",rnorm(rng));
}
```

R example:

```{Rcpp,eval=FALSE}
/***simulate_prior,θ=rnorm(1)***/
```

### evaluate_gradient_log_prior

The `evaluate_gradient_log_prior` function type gives the differential of the log prior density of the parameters.

Input: The variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable` in an R function

Input: The point at which the gradient of the log prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The gradient of the log prior density of the parameters.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_prior***/
arma::mat prior_gradient_eval(const std::string &variable,
                              const Parameters &parameters)
{
  if (variable=="θ")
  {
    arma::mat grad(1,1);
    grad(0,0) = -parameters["θ"][0];
    return grad;
  }
  else
  {
    Rcpp::stop("Unknown variable in prior gradient.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_prior,if (variable=="θ") {-parameters$θ} else {stop("Unknown variable in prior gradient.")}***/
```

### evaluate_second_gradient_log_prior

The `evaluate_gradient_log_prior` function type gives the second differential of the log prior density of the parameters.

Input: The first variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable1` in an R function
  
Input: The second variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable2` in an R function

Input: The point at which the gradient of the log prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The Hessian of the log prior density, evaluated at the given point.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_prior***/
arma::mat prior_gradient_eval(const std::string &variable1,
                              const std::string &variable2,
                              const Parameters &parameters)
{
  if ((variable1=="θ") && (variable2=="θ"))
  {
    arma::mat grad(1,1);
    grad(0,0) = -1.0;
    return grad;
  }
  else
  {
    Rcpp::stop("Unknown variable in prior second gradient.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_prior,if ((variable1=="θ") && (variable2=="θ")) {-1} else {stop("Unknown variable in prior second gradient.")}***/
```

## Factor: ilike prior {#ilike-prior}

### prior (ilike functions)

The `prior` function type allows the user to specify the prior through an ilike function (e.g. `ilike::norm`). For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted.

Example of the use of one of these functions (`ilike::norm`) follows.

```{Rcpp,eval=FALSE}
/***prior,ilike::norm(θ,0,1)***/
```

The following sections detail the available ilike functions.

#### Normal prior `ilike::norm`

Specifies a normal prior over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric: the mean of the normal distribution
    
  3. numeric: the standard deviation of the normal distribution
  
#### Multivariate normal prior `ilike::mvnorm`

Specifies a multivariate normal prior over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric vector/matrix: the mean of the multivariate normal distribution
    
  3. matrix: the covariance of the multivariate normal distribution
   
#### Lognormal prior `ilike::lnorm`
    
Specifies a lognormal prior over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric: the mean of the log of the variable
    
  3. numeric: the standard deviation of the log of the variable
    
#### Multivariate lognormal prior `ilike::mvlnorm`

Specifies a multivariate loggnormal prior over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric vector/matrix: the mean of the log of the variable
    
  3. matrix: the covariance of the log of the variable

#### Gamma prior `ilike::gamma`
    
Specifies a gamma prior over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the prior is specified
      
  2. numeric: the shape of the gamma distribution
    
  3. numeric: the rate of the gamma distribution

## Factor: custom likelihood

The functions in this section allow the specification of a user-defined likelihood. Only the functions required by the chosen inference algorithm need be specified.

Usually we recommend specifying, rather than a likelihood, the data model. This will ensure that, when running importance sampling for example, the normalising constant estimate returned by that algorithm will be an estimate of the marginal likelihood. However, where the goal is simulating from or approximating the posterior distribution, specifying the model up to proportionality is sufficient.

### evaluate_log_likelihood

The `evaluate_log_likelihood` function type calculates the log likelihood of the parameters.

Input: The point at which the log likelihood is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
 Input: The observed data for which the log likelihood is to be evaluated.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function

Output: The log likelihood of the parameters using the observed data.

  -- of type `double` in a C++ function
  
  -- of type `numeric` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_log_likelihood***/
double likelihood_eval(const Parameters &parameters,
                       const Data &data)
{
  double y = data["y"];
  return sum(dnorm(y,parameters["θ"][0],1.0));
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_log_likelihood,sum(dnorm(data$y,parameters$θ,1.0,log=TRUE))***/
```

### evaluate_gradient_log_likelihood

The `evaluate_gradient_log_likelihood` function type calculates the gradient of the log likelihood of the parameters.

Input: The variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable` in an R function
  
Input: The point at which the gradient of the log likelihood is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Input: The observed data for which the gradient of the log likelihood is to be evaluated.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function

Output: The gradient of the log likelihood of the parameters.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_likelihood***/
arma::mat likelihood_gradient_eval(const std::string &variable,
                                   const Parameters &parameters,
                                   const Data &data)
{
  if (variable=="θ")
  {
    arma::colvec y = data["y"];
    arma::mat grad(1,1);
    grad(0,0) = arma::sum((y-parameters["θ"][0])/1.0);
    return grad;
  }
  else
  {
    Rcpp::stop("Unknown variable in likelihood gradient.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_gradient_log_likelihood,if (variable=="θ") {sum((data$y-parameters$θ)/1.0)} else {stop("Unknown variable in likelihood gradient.")}***/
```

### evaluate_second_gradient_log_likelihood

The `evaluate_gradient_log_prior` function type gives the second differential of the log likelihood of the parameters.

Input: The first variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable1` in an R function
  
Input: The second variable with respect to which we wish to find the gradient.

  -- of type `const std::string &` in a C++ function
  
  -- available an R string `variable2` in an R function
  
Input: The point at which the gradient of the log prior is to be evaluated.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The Hessian of the log likelihood, evaluated at the given point.

  -- of type `arma::mat` in a C++ function
  
  -- of type `matrix` in R.

C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_likelihood***/
arma::mat likelihood_hessian_eval(const std::string &variable1,
                                  const std::string &variable2,
                                  const Parameters &parameters,
                                  const Data &data)
{
  if (variable1=="θ" && variable2=="θ")
  {
    arma::mat hess(1,1);
    hess(0,0) = -data["y"].size()/1.0;
    return hess;
  }
  else
  {
    Rcpp::stop("Unknown variable in likelihood hessian.");
  }
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_second_gradient_log_likelihood,if (variable1=="θ" && variable2=="θ") {-length(data$y)/1.0} else {stop("Unknown variable in likelihood hessian.")}***/
```

## Factor: simulation-based likelihood

The functions in this section allow the specification of a likelihood through a function that simulates a data generating process, for example through approximate Bayesian computation. There are three function types that are required to be specified for all simulation-based likelihoods:

- `simulate_data_model`, which simulates the data generating process.

- `data_variable`, which specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation.

- `sbi_likelihood`, which uses an ilike function to define the desired simulation-based likelihood.

It is also possible to reduce the observed data to summary statistcs (though the use of the `summary_statistics` function type) for use in the simulation-based likelihood.

### simulate_data_model

The `simulate_data_model` function type simulates the data generating process.

Input: (C++ only) The random number generator to be used in the simulation.

  -- of type `RandomNumberGenerator &` in a C++ function

Input: The parameters at which to simulate the data.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function

Output: The simulated data.

  -- of class `Data` in a C++ function
  
  -- an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an `=` sign in the function header.
  
C++ example:

```{Rcpp,eval=FALSE}
/***simulate_data_model***/
Data simulate_data_model(RandomNumberGenerator &rng,
                         const Parameters &parameters)
{
  arma::colvec y = rnorm(rng,100,parameters["θ"][0],1.0);
  return Data("y", y);
}
```

R example:

```{Rcpp,eval=FALSE}
/***simulate_data_model,y=rnorm(100,parameters$θ,1)***/
```

### data_variable

The `data_variable` function type specifies the variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. There are no input arguments.

Output: The variable or variables in the simulation that we wish to treat as observed for the purposes of constructing a likelihood based on the simulation. To specify multiple output variables they must be separated by a semi-colon (with no spaces).

  -- of type `const std::string &` in a C++ function
  
  -- a string in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***data_variable***/
std::string a_variable()
{
  return "y"; // could be "y;z" for variables y and z
}
```

R example:

```{Rcpp,eval=FALSE}
/***data_variable,"y"***/
```

### summary_statistics

The `summary_statistics` function type reduces the observed data to summary statistics for use in the simulation-based likelihood. The inclusion of this function type is optional: if it is included, then inference using the simulation-based likelihood will be conditional only on the summary statistics of the data, rather than the full data. If the argument is omitted, the simulation-based likelihood will use the full data.

Input: Simulated/observed data.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function
  
Output: The summary statistics of the data.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function
  
C++ example:

```{Rcpp,eval=FALSE}
/***summary_statistics***/
Data summary_statistics(const Data &data)
{
  arma::colvec y = data["y"];
  return Data("y_mean", arma::mean(y));
}
```

R example:

```{Rcpp,eval=FALSE}
/***summary_statistics,y_mean=mean(data$y)***/
```

### sbi_likelihood (ilike functions)

The `sbi_likelihood` function type uses an ilike function to define the desired simulation-based likelihood. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted.

Example of the use of one of these functions (`ilike::sl`) follows.

```{Rcpp,eval=FALSE}
/***sbi_likelihood,ilike::sl(50)***/
```

All of these methods use simulations from the data generating process (DGP) to construct an approximate likelihood from data $y_{\mbox{obs}}$. $s_{\mbox{obs}}$ is used to denote the result of applying the `summary_statistic` function to $y_{\mbox{obs}}$. Let $y^{1:M}$ be $M$ draws from the DGP $f(\cdot \mid \theta)$ for parameter $\theta$ and let $s^{1:M}$ be the result of applying the `summary_statistic` function to each corresponding simulation. Suppose that each summary statistic lies in $\mathbb{R}^{d_s}$: this vector is the result of stacking the summary statistics named in the `data_variable` function type.

The available ilike functions are detailed in the following sections.

#### Synthetic likelihood `ilike::sl` {#sl}

Specifies a synthetic likelihood (SL), as described in @wood2010statistical and @price2018bayesian. The synthetic likelihood $l(s_{\mbox{obs}} \mid \theta)$ is given by

$$
l(s_{\mbox{obs}} \mid \theta) = \mathcal{MVN}\left( s_{\mbox{obs}} \mid \hat{\mu}, \hat{\Sigma} \right),
(\#eq:sl)
$$ where
$$
\hat{\mu} = \frac{1}{M} \sum_{j=1}^M s^{j} \qquad \hat{\Sigma} = \frac{1}{M-1} \sum_{j=1}^M \left( s^{j} - \hat{\mu} \right) \left( s^{j} - \hat{\mu} \right)^T.
(\#eq:slmusigma)
$$ @price2018bayesian describes an extended version of this approach, which uses an unbiased estimate of the Gaussian distribution in equation \@ref(eq:sl), also based on $\hat{\mu}$ and $\hat{\Sigma}$ from equation \@ref(eq:slmusigma).

Inputs:

  1. integer: the number of simulations $M$ to use in the synthetic likelihood
  
  2. (optional) boolean: whether to use the unbiased version of synthetic likelihood described in @price2018bayesian (default is `false`)
  
  3. (optional) boolean: whether to store the output of the model simulations (default is `false`)
  
  4. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  5. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))
  
#### ABC (uniform kernel; Euclidean distance) `ilike::euclidean_uniform_abc`

Specifies an approximate Bayesian computation (ABC), using a uniform kernel and Euclidean distance metric, as described in @sisson2018handbook. The `euclidean_uniform_abc` likelihood $l(s_{\mbox{obs}} \mid \theta)$ is given, for tolerance level $\epsilon$, by

$$
l(s_{\mbox{obs}} \mid \theta) = \frac{1}{M}\sum_{j=1}^{M}K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right)
$$
where
$$
K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right) = \begin{cases} 1/c & \text{if } d( s_{\mbox{obs}} - s^{j} ) \leq \epsilon \\ 0 & \text{otherwise} \end{cases},
$$
for

$$
c = \frac{2^{d_s}\Gamma\left(\frac{1}{2}+1\right)^{d_s}}{\Gamma\left(\frac{d_s}{2}+1\right)}\epsilon^{d_s}\sum_{i=1}^{d_s}\sigma_{i}
$$
where

$$
d(s_{\text{obs}},s)=\left(\sum_{i=1}^{d_{s}}\left(\frac{s_{\text{obs},i}-s_{i}}{\sigma_{i}}\right)^{2}\right)^{1/2}
$$

Here $\sigma_i$ is a scaling used for the $i$th dimension of $s$. The value of $c$ is here to ensure that the uniform kernel is normalised, and uses the [formula for volume of a $d_s$-dimensional ball](https://www.johndcook.com/blog/2010/07/02/volumes-of-generalized-unit-balls/).

Inputs:

  1. integer: the number of simulations $M$ to use in the ABC
  
  2. string: the name of the tolerance variable in the ABC
  
  3. numeric: the tolerance level for the ABC
  
  4. (optional) string: the name of the variable that stores the scaling $\sigma_i$ of the data/summaries in the ABC (default is `""` - in this case the scale will be `1` for every dimension)
  
  5. (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 4) is set.
  
  6. (optional) boolean: whether to store the output of the model simulations (default is `false`)
  
  7. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  8. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))

#### ABC (uniform kernel; $L^p$ distance) `ilike::lp_uniform_abc`

Specified an approximate Bayesian computation (ABC) likelihood, using a uniform kernel and the $L^p$ distance metric. The `lp_uniform_abc` likelihood $l(y \mid \theta)$ is given, for tolerance level $\epsilon$, by

$$
l(s_{\mbox{obs}} \mid \theta) = \frac{1}{M}\sum_{j=1}^{M}K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right)
$$
where
$$
K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right) = \begin{cases} 1/c & \text{if } d( s_{\mbox{obs}} - s^{j} ) \leq \epsilon \\ 0 & \text{otherwise} \end{cases},
$$
for

$$
c = \frac{2^{d_s}\Gamma\left(\frac{1}{p}+1\right)^{d_s}}{\Gamma\left(\frac{d_s}{p}+1\right)}\epsilon^{d_s}\sum_{j=1}^{d_s}\sigma_{i}
$$
where

$$
d(s_{\text{obs}},s)=\left(\sum_{i=1}^{d_{s}}\left(\frac{s_{\text{obs},i}-s_{i}}{\sigma_{i}}\right)^{p}\right)^{1/p}
$$

Here $\sigma_i$ is a scaling used for the $i$th dimension of $s$. The value of $c$ is here to ensure that the uniform kernel is normalised, and uses the [formula for volume of a $d_s$-dimensional ball in $L^p$ space](https://www.johndcook.com/blog/2010/07/02/volumes-of-generalized-unit-balls/).

Inputs:

  1. integer: the number of simulations $M$ to use in the ABC
  
  2. string: the name of the tolerance variable in the ABC
  
  3. numeric: the tolerance level for the ABC
  
  4. numeric: the value of $p$ for the $L^p$ distance metric
  
  5. (optional) string: the name of the variable that stores the scaling $\sigma_i$ of the data/summaries in the ABC (default is `""` - in this case the scale will be `1` for every dimension)
  
  6. (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 5) is set.
  
  7. (optional) boolean: whether to store the output of the model simulations (default is `false`)
  
  8. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  9. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))

#### ABC (Gaussian kernel) `ilike::gaussian_abc` {#gaussian-abc}

Specifies an approximate Bayesian computation (ABC) likelihood, using a Gaussian kernel. The `gaussian_abc` likelihood $l(s_{\mbox{obs}} \mid \theta)$ is given, for tolerance level $\epsilon$, by

$$
l(s_{\mbox{obs}} \mid \theta) = \frac{1}{M}\sum_{j=1}^{M}K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right)
$$
where
$$
K_{\epsilon}\left(s_{\text{obs}}\mid s^{j}\right) = \left(2\pi\epsilon\right)^{-d_{y}/2}\prod_{i=1}^{d_{s}}\frac{1}{\sigma_{i}^{2}}\exp\left(-\frac{1}{2\epsilon^{2}}\sum_{i=1}^{d_{s}}\left(\frac{s_{\text{obs},i}-s_{i}}{\sigma_{i}}\right)^{2}\right).
$$
Here $\sigma_i$ is a scaling used for the $i$th dimension of $s$.

Inputs:

  1. integer: the number of simulations $M$ to use in the ABC
  
  2. string: the name of the tolerance variable in the ABC
  
  3. numeric: the tolerance level for the ABC
  
  4. (optional) string: the name of the variable that stores the scaling $\sigma_i$ of the data/summaries in the ABC (default is `""` - in this case the scale will be `1` for every dimension)
  
  5. (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 4) is set.
  
  6. (optional) boolean: whether to store the output of the model simulations (default is `false`)
  
  7. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  8. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))
  
#### IEnKI-ABC `ilike::ienki_abc`

Specifies an approximate Bayesian computation (ABC) likelihood, estimating using iterative ensemble Kalman inversion (IEnKI), as described in @everitt2024ensemble. This approach uses an alternative estimator for the ABC likelihood using the Gaussian kernel, with tolerance $\epsilon$, described in section \@ref(gaussian-abc). IEnKI uses an ensemble of points to simulate from a sequence of $0:T$ distributions using a decreasing sequence of tolerances $\infty = \epsilon_0 > .... > \epsilon_T = \epsilon$. The 0th distrbution is $f_s( s \mid \theta)$ (corresponding to the case where $\epsilon=\infty$), where $f_s$ is the distribution resulting from the data generating process $f( \cdot \mid \theta)$ and the summary statistic transformation. The $t$th distribution for $t>0$ is $f_s( s \mid \theta) K_{\epsilon_t}\left(s_{\text{obs}}\mid s\right)$. The estimator of the normalising constant of the final target distribution, constructed using the ensemble at each step of the IEnKI, is an estimator of the ABC likelihood. This estimator is biased in general, but is likely to have significantly lower variance than that from standard ABC. When the final $\epsilon$ is taken to be zero, and $T=1$, the estimator is the same as that used in synthetic likelihood (section \@ref(sl)). Full details can be found in @everitt2024ensemble.

Inputs:

  1. integer: the number of ensemble members $M$ to use in the IEnKI-ABC
  
  2. integer: the estimator type constructed from the IEnKI output. The meaning of each of the four options below is given in the paper @everitt2024ensemble. The options are:
  
  - `1` (recommended): the "direct" estimator
    
  - `2`: the "unbiased" estimator, using the approach analogous to the unbiased method in @price2018bayesian
    
  - `3`: the path sampling estimator
    
  - `4`: the alternative path sampling estimator from @friel2014improving
  
  3. string: the name of the tolerance variable in the ABC
  
  4. numeric: the tolerance level for the ABC
  
  5. string: the shifter used in the IEnKI (the method for moving the ensemble at each iteration). The options are:
  
  - `stochastic` (recommended): the stochastic shifter
  
  - `sqrt`: the square root shifter
  
  - `adjustment`: the adjustment shifter
  
  6. integer: the number of targets $T$ used in the IEnKI
  
  7. (optional) numeric: the significance level for the significance test used in determining when to use the target skipping approach proposed in @everitt2024ensemble (default is `1`, which results in skipping no targets; `0.1` recommended when using the stochastic shifter)
  
  8. (optional) integer: the number of iterations of output of each run of the IEnKI to store, counting from the final iteration backwards (default is `0`)
  
  9. (optional) string: the name of the variable that stores the scaling $\sigma_i$ of the data/summaries in the ABC (default is `""` - in this case the scale will be `1` for every dimension)
  
  10. (optional) numeric vector: the scaling of the data/summary in the ABC, which must be of the same dimension as the data/summary This is only used if the scale variable (argument 5) is set.
  
  11. (optional) boolean: whether to perform the IEnKI on the summary statistic space (default is `true`; `false` is largely untested)
  
  12. (optional) boolean: whether to run the simulations in parallel (default is `false`)
  
  13. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))

## Factor: linear-Gaussian model

A commonly-used class of model is one where data $y$ arises from a linear function of some latent state, plus some Gaussian noise, i.e.

$$
y \sim \mathcal{MVN}(H x, R)
(\#eq:lgdm)
$$
where $H$ is a matrix and $R$ is a covariance matrix. The linear-Gaussian data model subtype allows the specification of such model, through providing the variable names ($y$ and $x$ here) and the values for $H$ and $R$. Note that, using this block subtype, it would be possible to specify a model for a number of independent observations from a Gaussian distribution. However, this would be an inefficient way of specifying this model since it would require the user to supply a large diagonal covariance matrix. Such a model would be more effectively specified via the exact_likelihood block sutype.

There are two ways of specifying a linear-Gaussian data model:

1. Through the function types `linear_gaussian_data_variable` (specifying the name of the $y$ variable), `linear_gaussian_data_state_variable` (specifying the name of the $x$ variable), `linear_gaussian_data_matrix` (specifying the $A$ matrix), and `linear_gaussian_data_covariance` (specifying the name of the $\Sigma$ matrix), The user needs to provide **all** of these functions in order to fully specify the model.

2. Through the function type `linear_gaussian_data_model`, which allows the user to specify the complete model through an ilike function.

We now detail the function types.

### linear_gaussian_data_variable

Specifies the name of the observed data variable in the linear-Gaussian data model. There are no input arguments.

Output: The name of the variable used as $y$ in equation \@ref(eq:lgdm).

  -- of type `const std::string &` in a C++ function
  
  -- a string in R.

C++ example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_variable***/
std::string set_data_variable()
{
  return "y";
}
```

R example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_variable,"y"***/
```

### linear_gaussian_data_state_variable

Specifies the name of the latent state variable in the linear-Gaussian data model. There are no input arguments.

Output: The name of the variable used as $x$ in equation \@ref(eq:lgdm).

  -- of type `const std::string &` in a C++ function
  
  -- a string in R.
  
C++ example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_state_variable***/
std::string set_state_variable()
{
  return "x";
}
```

R example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_state_variable,"x"***/
```

### linear_gaussian_data_matrix

Specifies the matrix $A$ in the linear-Gaussian data model.

Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function

Output: The matrix $A$ in equation \@ref(eq:lgdm).

  -- of type `arma::mat` in a C++ function
  
  -- a matrix in R.
  
C++ examples:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_matrix***/
arma::mat set_matrix()
{
  arma::mat A(2,2);
  A(0,0) = 1.0;
  A(0,1) = 0.0;
  A(1,0) = 0.0;
  A(1,1) = 1.0;
  return A;
}
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_matrix***/
arma::mat set_matrix(const Parameters &parameters)
{
  double scale = parameters["scale"][0];
  arma::mat A(2,2);
  A(0,0) = scale;
  A(0,1) = 0.0;
  A(1,0) = 0.0;
  A(1,1) = scale;
  return A;
}
```

R example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_matrix,diag(2)***/
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_matrix,parameters$scale*diag(2)***/
```

### linear_gaussian_data_covariance

Specifies the covariance matrix $R$ in the linear-Gaussian data model.

Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The covariance matrix $R$ in equation \@ref(eq:lgdm).

  -- of type `arma::mat` in a C++ function
  
  -- a matrix in R
 
C++ examples:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_covariance***/
arma::mat set_covariance()
{
  arma::mat R(2,2);
  R(0,0) = 1.0;
  R(0,1) = 0.0;
  R(1,0) = 0.0;
  R(1,1) = 1.0;
  return R;
}
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_covariance***/
arma::mat set_covariance(const Parameters &parameters)
{
  double scale = parameters["scale"][0];
  arma::mat R(2,2);
  R(0,0) = scale;
  R(0,1) = 0.0;
  R(1,0) = 0.0;
  R(1,1) = scale;
  return R;
}
```
 
R examples:

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_covariance,diag(2)***/
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_data_covariance,parameters$scale*diag(2)***/
```

### linear_gaussian_data_model (ilike function)

We may use an ilike function to specify the complete linear-Gaussian data model.

#### Linear-Gaussian data model `ilike::linear_gaussian_data_model`

Specifies the linear-Gaussian data model.

Inputs:

  1. string: The name of the observed data variable
  
  2. string: The name of the latent state variable
  
  3. matrix: The matrix $A$
  
  4. matrix: The covariance matrix $R$
  
## Factor: nonlinear-Gaussian model

The nonlinear-Gaussian data model subtype may be used to specify a model where data $y$ arises from a nonlinear function of some latent state, plus some Gaussian noise, i.e.

$$
y \sim \mathcal{N}(g(x), R)
(\#eq:nlgdm)
$$
where $g$ is a function and $R$ is a covariance matrix. To specify the model we need to provide the variable name ($y$), the function $g$ and the matrix $R$. To do this the user must provide three function types, respectively: `nonlinear_gaussian_data_variable`, `nonlinear_gaussian_data_function` and `nonlinear_gaussian_data_covariance`.

### nonlinear_gaussian_data_variable

Specifies the name of the observed data variable. There are no input arguments.

Output: The name of the observed data variable.

  -- of type `const std::string &` in a C++ function
  
  -- a string in R.

C++ example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_variable***/
std::string set_variable()
{
  return "y";
}
```

R example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_variable,"y"***/
```

### nonlinear_gaussian_data_function

Specifies the function $g$ in the nonlinear-Gaussian data model.

Input: The state $x$ and any parameters that the function relies on (the latter may be included to allow the specification of a parameter-dependent function)

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The output of the function $g$ in equation \@ref(eq:nlgdm).

  -- of type `const Data &` in a C++ function
  
  -- a list in R.

C++ example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_function***/
Data transform_into_data_space(const Parameters &x_and_theta)
{
  arma::colvec noiseless_y(1,1);
  noiseless_y[0] = exp(x_and_theta["x"][0) + x_and_theta["theta"][0];
  return Data("y", noiseless_y);
}
```

R example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_function,y=exp(parameters$x)+parameters$theta***/
```

### nonlinear_gaussian_data_covariance

Specifies the covariance matrix $R$ in the nonlinear-Gaussian data model.

Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The covariance matrix $R$ in equation \@ref(eq:nlgdm).

  -- of type `arma::mat` in a C++ function
  
  -- a matrix in R.
  
C++ examples:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_covariance***/
arma::mat set_covariance()
{
  arma::mat R(2,2);
  R(0,0) = 1.0;
  R(0,1) = 0.0;
  R(1,0) = 0.0;
  R(1,1) = 1.0;
  return R;
}
```

or

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_covariance***/
arma::mat set_covariance(const Parameters &parameters)
{
  double scale = parameters["scale"][0];
  arma::mat R(2,2);
  R(0,0) = scale;
  R(0,1) = 0.0;
  R(1,0) = 0.0;
  R(1,1) = scale;
  return R;
}
```
 
R examples:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_covariance,diag(2)***/
```

or

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_data_covariance,parameters$scale*diag(2)***/
```

## Factor: algorithmic likelihood

For some models, the likelihood can be computed or estimated by running an algorithm. For example, the marginal likelihood of a state-space model may be estimated using a particle filter. To specify such a likelihood, the user must provide a function type `algorithmic_likelihood`, then use an ilike function to specify the type of likelihood.

### algorithmic_likelihood (ilike functions)

The likelihood function type allows the user to specify the likelihood through an ilike function. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted.

The available ilike functions are detailed in the following sections.

#### Kalman filter `ilike::kf`

The Kalman filter (KF) is a recursive algorithm that estimates the state of a linear Gaussian state-space model and, in this context, can be used to calculate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running a KF from the ilike R package as described in section \@ref(kf).

Inputs:

  1. string: The name of an ilike file (with extension) that contains the specification of a linear-Gaussian state-space model and the required ilike function for setting up a filter, as described in section \@ref(filter). A full description of what is required in the file is given in section \@ref(kf).
  
  2. (optional) integer: THe number of iterations output of the KF to store, counting from the final iteration backwards (default is `0`)
  
#### Particle filter `ilike::pf`

The particle filter is a recursive algorithm that estimates the state of a general state-space model and, in this context, can be used to estimate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running a PF from the ilike R package as described in section \@ref(pf).

Inputs:

  1. string: The name of an ilike file (with extension) that contains the specification of a general state-space model and the required ilike function for setting up a filter, as described in section \@ref(filter). A full description of what is required in the file is given in section \@ref(pf).

  2. integer: The number of particles to use in the particle filter.
  
  3. (optional) integer: The number of iterations output of the PF to store, counting from the final iteration backwards (default is `0`).
  
  4. (optional) boolean: Whether to run the particle filter in parallel (default is `false`).
  
  5. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))
  
#### Ensemble Kalman filter `ilike::enkf`

The ensemble Kalman filter (EnKF) is a recursive algorithm that estimates the state of a general state-space model and, in this context, can be used to estimate the marginal likelihood of parameters of the model. The arguments required for this ilike function follow as closely as possible those required for running an EnKF from the ilike R package as described in section \@ref(enkf).

Inputs:

  1. string: The name of an ilike file (with extension) that contains the specification of a general state-space model and the required ilike function for setting up a filter, as described in section \@ref(filter). A full description of what is required in the file is given in section \@ref(enkf).

  2. integer: The number of ensemble members to use in the EnKF.
  
  3. string: The name of the shifter to use in the EnKF (the method for moving the ensemble at each iteration). The options are:
  
  - `stochastic`: the stochastic shifter
  
  - `sqrt`: the square root shifter
  
  - `adjustment`: the adjustment shifter
  
  4. (optional) integer: The number of iterations output of the EnKF to store, counting from the final iteration backwards (default is `0`).
  
  5. (optional) boolean: Whether to run the EnKF in parallel (default is `false`).
  
  6. (optional) integer: the grain size for parallelisation (default is `100000`; see [guidance here](https://oneapi-src.github.io/oneTBB/main/tbb_userguide/Controlling_Chunking_os.html))


## Transition model: linear-Gaussian

The linear-Gaussian transition model subtype may be used to specify a transition model in a state-space model that consists of a linear function of the state, plus some Gaussian noise, i.e.

$$
x_t \sim \mathcal{N}(A x_{t-1}, Q)
(\#eq:lgtm)
$$
where $A$ is a matrix and $Q$ is a covariance matrix. To specify the model we need to provide the state name ($x$), the matrix $A$ and the matrix $Q$.

There are two ways of specifying a linear-Gaussian data model:

1. Through the function types `linear_gaussian_transition_variable` (specifying the name of the $x$ variable), `linear_gaussian_transition_matrix` (specifying the $A$ matrix), and `linear_gaussian_transition_covariance` (specifying the name of the $Q$ matrix), The user needs to provide **all** of these functions in order to fully specify the model.

2. Through the function type `linear_gaussian_transition_model`, which allows the user to specify the complete model through an ilike function.

We now detail the function types.

### linear_gaussian_transition_variable

Specifies the name of the observed transition variable in the linear-Gaussian transition model. There are no input arguments.

Output: The name of the variable used as $x$ in equation \@ref(eq:lgtm).

  -- of type `const std::string &` in a C++ function
  
  -- a string in R.

C++ example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_transition_variable***/
std::string set_transition_variable()
{
  return "x";
}
```

R example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_transition_variable,"x"***/
```

### linear_gaussian_transition_matrix

Specifies the matrix $A$ in the linear-Gaussian transition model.

Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function

Output: The matrix $A$ in equation \@ref(eq:lgtm).

  -- of type `arma::mat` in a C++ function
  
  -- a matrix in R.
  
C++ examples:

```{Rcpp,eval=FALSE}
/***linear_gaussian_transition_matrix***/
arma::mat set_matrix()
{
  arma::mat A(2,2);
  A(0,0) = 1.0;
  A(0,1) = 0.0;
  A(1,0) = 0.0;
  A(1,1) = 1.0;
  return A;
}
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_transition_matrix***/
arma::mat set_matrix(const Parameters &parameters)
{
  double scale = parameters["scale"][0];
  arma::mat A(2,2);
  A(0,0) = scale;
  A(0,1) = 0.0;
  A(1,0) = 0.0;
  A(1,1) = scale;
  return A;
}
```

R example:

```{Rcpp,eval=FALSE}
/***linear_gaussian_transition_matrix,diag(2)***/
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_transition_matrix,parameters$scale*diag(2)***/
```

### linear_gaussian_transition_covariance

Specifies the covariance matrix $Q$ in the linear-Gaussian transition model.

Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The covariance matrix $Q$ in equation \@ref(eq:lgtm).

  -- of type `arma::mat` in a C++ function
  
  -- a matrix in R
 
C++ examples:

```{Rcpp,eval=FALSE}
/***linear_gaussian_transition_covariance***/
arma::mat set_covariance()
{
  arma::mat Q(2,2);
  Q(0,0) = 1.0;
  Q(0,1) = 0.0;
  Q(1,0) = 0.0;
  Q(1,1) = 1.0;
  return Q;
}
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_transition_covariance***/
arma::mat set_covariance(const Parameters &parameters)
{
  double scale = parameters["scale"][0];
  arma::mat Q(2,2);
  Q(0,0) = scale;
  Q(0,1) = 0.0;
  Q(1,0) = 0.0;
  Q(1,1) = scale;
  return Q;
}
```
 
R examples:

```{Rcpp,eval=FALSE}
/***linear_gaussian_transition_covariance,diag(2)***/
```

or

```{Rcpp,eval=FALSE}
/***linear_gaussian_transition_covariance,parameters$scale*diag(2)***/
```

### linear_gaussian_transition_model (ilike function)

We may use an ilike function to specify the complete linear-Gaussian transition model.

#### Linear-Gaussian transition model `ilike::linear_gaussian_transition_model`

Specifies the linear-Gaussian transition model.

Inputs:

  1. string: The name of the observed transition variable
  
  2. string: The name of the latent state variable
  
  3. matrix: The matrix $A$
  
  4. matrix: The covariance matrix $Q$
  
## Transition model: nonlinear-Gaussian

The nonlinear-Gaussian transition model subtype may be used to specify a model where the state $x_t$ has a Gaussian distribution where the mean depends nonlinearly on $x_{t-1}$, plus some Gaussian noise, i.e.

$$
x_t \sim \mathcal{N}(g(x_{t-1}), Q)
(\#eq:nlgtm)
$$
where $g$ is a function and $Q$ is a covariance matrix. To specify the model we need to provide the variable name ($x$), the function $g$ and the matrix $Q$. To do this the user must provide three function types, respectively: `nonlinear_gaussian_transition_variable`, `nonlinear_gaussian_transition_function` and `nonlinear_gaussian_transition_covariance`.

### nonlinear_gaussian_transition_variable

Specifies the name of the observed transition variable. There are no input arguments.

Output: The name of the observed transition variable.

  -- of type `const std::string &` in a C++ function
  
  -- a string in R.

C++ example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_transition_variable***/
std::string set_variable()
{
  return "x";
}
```

R example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_transition_variable,"x"***/
```

### nonlinear_gaussian_transition_function

Specifies the function $g$ in the nonlinear-Gaussian transition model.

Input: The state $x$ and any parameters that the function relies on (the latter may be included to allow the specification of a parameter-dependent function)

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The output of the function $g$ in equation \@ref(eq:nlgtm).

  -- of type `const Parameters &` in a C++ function
  
  -- a list in R.

C++ example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_transition_function***/
Parameters transform_state(const Parameters &xtminus1_and_theta)
{
  arma::colvec noiseless_xt(1,1);
  noiseless_xt[0] = exp(xtminus1_and_theta["x"][0) + xtminus1_and_theta["theta"][0];
  return Parameters("x", noiseless_xt);
}
```

R example:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_transition_function,x=exp(parameters$x)+parameters$theta***/
```

### nonlinear_gaussian_transition_covariance

Specifies the covariance matrix $Q$ in the nonlinear-Gaussian transition model.

Input (optional): Parameters that the matrix relies on, to allow the specification of a parameter-dependent matrix.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The covariance matrix $Q$ in equation \@ref(eq:nlgtm).

  -- of type `arma::mat` in a C++ function
  
  -- a matrix in R.
  
C++ examples:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_transition_covariance***/
arma::mat set_covariance()
{
  arma::mat Q(2,2);
  Q(0,0) = 1.0;
  Q(0,1) = 0.0;
  Q(1,0) = 0.0;
  Q(1,1) = 1.0;
  return Q;
}
```

or

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_transition_covariance***/
arma::mat set_covariance(const Parameters &parameters)
{
  double scale = parameters["scale"][0];
  arma::mat Q(2,2);
  Q,0) = scale;
  Q(0,1) = 0.0;
  Q(1,0) = 0.0;
  Q(1,1) = scale;
  return Q;
}
```
 
R examples:

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_transition_covariance,diag(2)***/
```

or

```{Rcpp,eval=FALSE}
/***nonlinear_gaussian_transition_covariance,parameters$scale*diag(2)***/
```

## Transition model: custom

The functions in this section allow the specification of a user-defined transition model. The two possible function types are `simulate_transition_model` and `evaluate_log_transition_model`. Only the functions required by the chosen inference algorithm need be specified: for example, bootstrap particle filter does not need to evaluate the density of the transition model, so this function type does not need to be provided.

### simulate_transition model

The `simulate_transition_model` function type simulates the latent state at time $t$ given the latent state at time $t-1$ and any parameters that the model relies on.

Input: (C++ only) The random number generator.

  -- of type `RandomNumberGenerator &` in a C++ function

Input: The latent state at time $t-1$ and any parameters that the model relies on.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The latent state at time $t$.

  -- of type `const Parameters &` in a C++ function
  
  -- of type `list` in R
  
C++ example:

```{Rcpp,eval=FALSE}
/***simulate_transition_model***/
Parameters simulate_state(RandomNumberGenerator &rng,
                          const Parameters &xtminus1_and_theta)
{
  arma::colvec xt(1,1);
  noiseless_xt[0] = rnorm(rng,1,exp(xtminus1_and_theta["x"][0) + xtminus1_and_theta["theta"][0],1.0);
  return Parameters("x", noiseless_xt);
}
```

R example:

```{Rcpp,eval=FALSE}
/***simulate_transition_model,x=rnorm(1,exp(parameters$x)+parameters$theta,1)***/
```

### evaluate_log_transition_model

The `evaluate_log_transition_model` function type evaluates the log transition density of the latent state at time $t$ given the latent state at time $t-1$ and any parameters that the model relies on.

Input: The proposed latent state at time $t$ and any parameters that the model relies on.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `proposed_parameters` in an R function
  
Input: The latent state at time $t-1$ and any parameters that the model relies on.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Output: The log transition density of the latent state at time $t$ given the latent state at time $t-1$. 

  -- of type `double` in a C++ function
  
  -- of type `numeric` in R
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_log_transition_model***/
double log_transition_density(const Parameters &proposed_parameters,
                              const Parameters &parameters)
{
  double x = proposed_parameters["x"][0];
  double xminus1 = parameters["x"][0];
  double theta = parameters["theta"][0];
  return dnorm(x, exp(xminus1) + theta, 1.0);
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_log_transition_model,dnorm(parameters$x,exp(parameters$x)+parameters$theta,1,log=TRUE)***/
```



## Data block

### data

The `data` function type returns observed data. There are no input arguments.

Output: The observed data.

  -- of class `Data` in a C++ function
  
  -- an R list in R, where at present the interface restricts the user to a single vector/matrix of data, which is indexed by a string provided by the user to the left of an `=` sign in the function header.
  
C++ example:

```{Rcpp,eval=FALSE}
/***data***/
Data set_data()
{
  arma::colvec y(2,1);
  y[0] = 1.0;
  y[1] = 2.0;
  return Data("y", y);
}
```

R example:

```{Rcpp,eval=FALSE}
/***data,y=c(1,2)***/
```

## Importance proposal: custom

The functions in this section allow the specification of a user-defined importance proposal. A custom importance sampling proposal requires the specification of two function types: `simulate_importance_proposal` and `evaluate_log_importance_proposal`.

### simulate_importance_proposal

The `simulate_importance_proposal` function type simulates an importance sampling proposal distribution. There are two optional arguments for this function type, allowing the proposal to depend on some parameters, or the observed data. If both arguments are provided, the `proposal_parameters` argument must appear directly before the `data` argument.

Input: (C++ only) The random number generator.

  -- of type `RandomNumberGenerator &` in a C++ function
  
Input: (optional) Any parameters the proposal relies on.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `proposal_parameters` in an R function
  
Input: (optional) Any data the proposal relies on.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function
  
Output: The proposed parameters.

  -- of type `const Parameters &` in a C++ function
  
  -- of type `list` in R
  
C++ example:

```{Rcpp,eval=FALSE}
/***simulate_importance_proposal***/
Parameters simulate_proposal(RandomNumberGenerator &rng,
                              const Parameters &proposal_parameters)
{
  arma::colvec x(1,1);
  x[0] = rnorm(rng, 0.0, proposal_parameters["theta"][0]]);
  return Parameters("x", x);
}
```

R example:

```{Rcpp,eval=FALSE}
/***simulate_importance_proposal,x=rnorm(1,0,proposal_parameters$theta)***/
```

### evaluate_log_importance_proposal

The `evaluate_log_importance_proposal` function type evaluates the log density of the importance sampling proposal distribution. As for `simulate_importance_proposal`, there are two optional arguments for this function type, allowing the proposal to depend on some parameters, or the observed data. The arguments that are chosen must be specified in the order of the inputs listed below.

Input: The proposed parameters.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `proposed_parameters` in an R function
  
Input: (optional) Any parameters the proposal relies on.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `proposal_parameters` in an R function
  
Input: (optional) Any data the proposal relies on.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function
  
Output: The log density of the proposed parameters under the proposal distribution.

  -- of type `double` in a C++ function
  
  -- of type `numeric` in R
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_log_importance_proposal***/
double log_importance_density(const Parameters &proposed_parameters,
                              const Parameters &proposal_parameters)
{
  double x = proposed_parameters["x"][0];
  double theta = proposal_parameters["theta"][0];
  return dnorm(x, 0.0, theta);
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_log_importance_proposal,dnorm(proposed_parameters$x,0,proposal_parameters$theta,log=TRUE)***/
```

## Importance proposal: ilike

### importance_proposal (ilike functions)

The `importance_proposal` function type allows the user to specify the prior through an ilike function (e.g. `ilike::norm`). For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted.

Example of the use of one of these functions (`ilike::norm`) follows.

```{Rcpp,eval=FALSE}
/***importance_proposal,ilike::norm(θ,0,1)***/
```

The following sections detail the available ilike functions.

#### Normal proposal `ilike::norm`

Specifies a normal proposal over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the proposal is specified
      
  2. numeric: the mean of the normal distribution
    
  3. numeric: the standard deviation of the normal distribution
  
#### Multivariate normal proposal `ilike::mvnorm`

Specifies a multivariate normal proposal over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the proposal is specified
      
  2. numeric vector/matrix: the mean of the multivariate normal distribution
    
  3. matrix: the covariance of the multivariate normal distribution
   
#### Lognormal proposal `ilike::lnorm`
    
Specifies a lognormal proposal over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the proposal is specified
      
  2. numeric: the mean of the log of the variable
    
  3. numeric: the standard deviation of the log of the variable
    
#### Multivariate lognormal proposal `ilike::mvlnorm`

Specifies a multivariate loggnormal proposal over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the proposal is specified
      
  2. numeric vector/matrix: the mean of the log of the variable
    
  3. matrix: the covariance of the log of the variable

#### Gamma proposal `ilike::gamma`
    
Specifies a gamma proposal over the given variable, with the given parameters.

Inputs:

  1. string: the variable for which the proposal is specified
      
  2. numeric: the shape of the gamma distribution
    
  3. numeric: the rate of the gamma distribution

## MH proposal: custom

The functions in this section allow the specification of a user-defined Metropolis-Hastings (MH) proposal. A custom MH proposal requires the specification of two function types: `simulate_mh_proposal` and `evaluate_log_mh_proposal`.

### simulate_mh_proposal

The `simulate_mh_proposal` function type simulates an MH proposal distribution. There are two optional arguments for this function type, allowing the proposal to depend on some parameters, or the observed data. The arguments that are chosen must be specified in the order of the inputs listed below.

Input: (C++ only) The random number generator.

  -- of type `RandomNumberGenerator &` in a C++ function
  
Input: The current state of the MCMC chain.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Input: (optional) Any parameters the proposal relies on.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `proposal_parameters` in an R function
  
Input: (optional) Any data the proposal relies on.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function
  
Output: The proposed parameters.

  -- of type `const Parameters &` in a C++ function
  
  -- of type `list` in R
  
C++ example:

```{Rcpp,eval=FALSE}
/***simulate_mh_proposal***/
Parameters simulate_proposal(RandomNumberGenerator &rng,
                             const Parameters &parameters,
                             const Parameters &proposal_parameters)
{
  arma::colvec x(1,1);
  x[0] = rnorm(rng, parameters["x"][0], proposal_parameters["theta"][0]]);
  return Parameters("x", x);
}
```

R example:

```{Rcpp,eval=FALSE}
/***simulate_mh_proposal,x=rnorm(1,parameters$x,proposal_parameters$theta)***/
```

### evaluate_log_mh_proposal

The `evaluate_log_mh_proposal` function type evaluates the log density of the MH proposal distribution. As for `simulate_mh_proposal`, there are two optional arguments for this function type, allowing the proposal to depend on some parameters, or the observed data. The arguments that are chosen must be specified in the order of the inputs listed below.

Input: The proposed parameters.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `proposed_parameters` in an R function
  
Input: The current state of the MCMC chain.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `parameters` in an R function
  
Input: (optional) Any parameters the proposal relies on.

  -- of type `const Parameters &` in a C++ function
  
  -- available as R list `proposal_parameters` in an R function
  
Input: (optional) Any data the proposal relies on.

  -- of type `const Data &` in a C++ function
  
  -- available as R list `data` in an R function
  
Output: The log density of the proposed parameters under the proposal distribution.

  -- of type `double` in a C++ function
  
  -- of type `numeric` in R
  
C++ example:

```{Rcpp,eval=FALSE}
/***evaluate_log_mh_proposal***/
double log_mh_density(const Parameters &proposed_parameters,
                      const Parameters &parameters,
                      const Parameters &proposal_parameters)
{
  double proposed_x = proposed_parameters["x"][0];
  double current_x = parameters["x"][0];
  double theta = proposal_parameters["theta"][0];
  return dnorm(proposed_x, current_x, theta);
}
```

R example:

```{Rcpp,eval=FALSE}
/***evaluate_log_mh_proposal,dnorm(proposed_parameters$x,parameters$x,proposal_parameters$theta,log=TRUE)***/
```

## mh proposal: ilike

### mh_proposal (ilike functions)

The `mh_proposal` function type allows the user to specify the prior through an ilike function. For all ilike functions we give the required arguments, stating their required type (using R types). Recall that the input arguments must be specified in the correct order. Some functions have optional arguments, which can only be omitted if arguments following them are also omitted.

The following sections detail the available ilike functions.

#### Normal random walk proposal `ilike::norm_rw`

Specifies a normal random walk proposal over the given variable, where the proposed state $\theta^*$ is simulated using

$$
\theta^* \sim \mathcal{N}(\theta}, \sigma)
$$

Inputs:

  1. string: the variable for which the proposal is specified
    
  2. numeric: the standard deviation $\sigma$ of the normal distribution
  
#### Multivariate normal random walk proposal `ilike::mvnorm_rw`

Specifies a multivariate random walk normal proposal over the given variable, where the proposed state $\theta^*$ is simulated using

$$
\theta^* \sim \mathcal{MVN}(\theta, s^2 \Sigma)
$$

Inputs:

  1. string: the variable for which the proposal is specified
    
  2. matrix: the covariance $\Sigma$ of the multivariate normal distribution
  
  3. numeric: the scaling factor $s^2$ of the covariance matrix (default is 1)
   
#### Uniform random walk proposal `ilike::unif_rw`

Specifies a uniform random walk proposal over the given variable, where the proposed state $\theta^*$ is simulated using

$$
\theta^* \sim \mathcal{U}(\theta - \sigma, \theta} + \sigma)
$$


Inputs:

  1. string: the variable for which the proposal is specified
    
  2. numeric: the half-width of the uniform distribution
  
#### Multivariate uniform random walk proposal `ilike::mvunif_rw`

Specifies a multivariate random walk normal proposal over the given variable, where proposed state $\theta^*$ is simulated using

$$
\theta^* \sim \mathcal{MVU}(\theta - \Sigma, \theta + \Sigma)
$$

Inputs:

  1. string: the variable for which the proposal is specified
    
  2. vector/matrix: a matrix of half-widths of the uniform distribution, which must have the same dimensionality as $\theta$

#### Langevin proposal `ilike::langevin`
    
Specifies a Langevin proposal over the given variable, where the proposed state $\theta^*$ is simulated using

$$
\theta^* \sim \mathcal{MVN}(\theta + \frac{s^2}{2} \Sigma \grad \log \pi(\theta), s^2 \Sigma)
$$
The presence of $\grad \log \pi(\theta)$ in the proposal requires that the gradient of the log of each factor must be available. $s^2$ is scaling factor for the preconditioning matrix $\Sigma$.

Inputs:

  1. string: the variable for which the proposal is specified
      
  2. matrix: the covariance $\Sigma$ of the multivariate normal distribution used in the proposal
    
  3. numeric: the scaling factor $s^2$ of the covariance matrix (default is 1)

#### Barker proposal `ilike::barker`

Specifies a Barker proposal over the given variable, as described in @livingstone2022barker, where the proposed state $\theta^*$ is simulated using the following procedure. For the following, let: $d$ be the dimension of $\theta$, $\mathbf{0}_d$ be the zero vector in $\mathbb{R}$; $\mathbf{1}_d$ be the vector of ones in $\mathbb{R}$; $\odot$ be the Hadamard (element-wise) product; and $.<$ denote an element-wise less than operator on two vectors in $\mathbb{R}^d$, which outputs $+1$ in position $i$ when the corresponding elements satisfy $<$ and $-1$ otherwise. 

$$
z \sim \mathcal{MNV}(\mathbf{0}_d, s^2 \Sigma)
$$
$$
u \sim \mathcal{U}(\mathbf{0}_d,\mathbf{1}_d)
$$
$$
b = \left( u .< 1/(1 + \exp(-z \odot \grad \log \pi(\theta))) \right)
$$

$$
\theta^* = \theta + b \odot z
$$
The presence of $\grad \log \pi(\theta)$ in the proposal requires that the gradient of the log of each factor must be available. $s^2$ is scaling factor for the preconditioning matrix $\Sigma$.

Inputs:

  1. string: the variable for which the proposal is specified
    
  2. matrix: the covariance $\Sigma$ of the multivariate normal distribution used in the proposal
  
  3. numeric: the scaling factor $s^2$ of the covariance matrix (default is 1)
  
#### Mirror proposal `ilike::mirror`



## Method block

### filter {#filter}

#### Filtering instructions `ilike::filter`

// Arguments are:
// name of index variable
// first index
// final index
// name of time variable
// initial time
// time step variable
// time step size
// predictions per update
/***filter,ilike::filter(i,0,15,t,0,dt,2,1)***/




```{r}
  prior_function_types = c("prior","evaluate_log_prior","simulate_prior","evaluate_gradient_log_prior","evaluate_second_gradient_log_prior")
  custom_likelihood_function_types = c("evaluate_log_likelihood","evaluate_gradient_log_likelihood","evaluate_second_gradient_log_likelihood")
  #file_likelihood_types = c("importance_sample","smc_mcmc_move")
  sbi_likelihood_function_types = c("simulate_data_model","sbi_likelihood","summary_statistics","data_variable")
  linear_gaussian_data_model_types = c("linear_gaussian_data_model","linear_gaussian_data_matrix","linear_gaussian_data_covariance","linear_gaussian_data_variable","linear_gaussian_data_state_variable")
  nonlinear_gaussian_data_model_types = c("nonlinear_gaussian_data_model","nonlinear_gaussian_data_function","nonlinear_gaussian_data_covariance","nonlinear_gaussian_data_variable")
  other_likelihood_function_types = c("likelihood")
  factor_function_types = c(prior_function_types,custom_likelihood_function_types,sbi_likelihood_function_types,linear_gaussian_data_model_types,nonlinear_gaussian_data_model_types,other_likelihood_function_types)
  ilike_transition_model_types = c("transition_model")
  linear_gaussian_transition_model_types = c("linear_gaussian_transition_model","linear_gaussian_transition_matrix","linear_gaussian_transition_covariance","linear_gaussian_transition_variable")
  nonlinear_gaussian_transition_model_types = c("nonlinear_gaussian_transition_model","nonlinear_gaussian_transition_function","nonlinear_gaussian_transition_covariance","nonlinear_gaussian_transition_variable")
  custom_transition_model_types = c("simulate_transition_model","evaluate_log_transition_model")
  transition_model_types = c(ilike_transition_model_types,linear_gaussian_transition_model_types,nonlinear_gaussian_transition_model_types,custom_transition_model_types)
  custom_potential_function_types = c("evaluate_log_potential_function")
  ilike_potential_function_types = c("potential_function")
  potential_function_types = c(custom_potential_function_types,ilike_potential_function_types)
  data_function_types = c("data")
  importance_proposal_types = c("simulate_importance_proposal","evaluate_log_importance_proposal","importance_proposal")
  mh_proposal_types = c("simulate_mh_proposal","evaluate_log_mh_proposal","mh_proposal","mh_transform","mh_inverse_transform","mh_transform_jacobian_matrix","mh_factor_index")
  unadjusted_proposal_types = c("simulate_unadjusted_proposal","unadjusted_proposal","unadjusted_transform","unadjusted_inverse_transform","unadjusted_transform_jacobian_matrix","unadjusted_factor_index")
  independent_mh_proposal_types = c("simulate_independent_mh_proposal","evaluate_log_independent_mh_proposal","independent_mh_proposal","independent_mh_transform","independent_mh_inverse_transform","independent_mh_transform_jacobian_matrix","independent_mh_factor_index")
  m_proposal_types = c("simulate_m_proposal","m_proposal","m_transform","m_inverse_transform","m_transform_jacobian_matrix","m_factor_index")
  transition_proposal_types = c("simulate_transition_proposal","evaluate_log_transition_proposal")
  enk_transform_types = c("enk_transform","enk_inverse_transform")
  #reinforce_gradient = c("reinforce_gradient")
  method_function_types = c("mcmc_weights","mcmc_termination","adaptive_resampling","adaptive_target","smc_termination","smc_sequence","reinforce_gradient","enk_likelihood_index","enk_shifter","filter")
```